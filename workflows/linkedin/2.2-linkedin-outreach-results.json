{
  "updatedAt": "2026-02-10T00:50:08.471Z",
  "createdAt": "2026-02-10T00:42:43.684Z",
  "id": "ZUqVzkqYvfBjg6tj",
  "name": "2.2 LinkedIn Outreach - Results [V2]",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "outreach-results",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "wf2v2r-webhook",
      "name": "PB Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        4800,
        400
      ],
      "webhookId": "d4e5f6a7-b8c9-4012-def3-456789abcdef"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        4800,
        608
      ],
      "id": "wf2v2r-manual",
      "name": "When clicking 'Execute workflow'"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map((item, index) => {\n  // 1. Access the 'body' property where n8n stores webhook data\n  const body = item.json.body || {};\n  console.log(`--- Processing Webhook Item ${index} ---`);\n\n  // 2. Extract the resultObject string\n  const rawResult = body.resultObject || \"[]\";\n  \n  let parsedResults = [];\n  try {\n    // 3. Parse the string into a real array\n    parsedResults = JSON.parse(rawResult);\n    console.log(`Parsed ${parsedResults.length} connections from resultObject.`);\n  } catch (e) {\n    console.error(\"JSON Parse Error:\", e.message);\n  }\n\n  // 4. Get the owner from the first connection in the list\n  const firstConnection = parsedResults[0] || {};\n  const ownerName = firstConnection.inviterName || \"Unknown\";\n  console.log(`Detected Owner: \"${ownerName}\"`);\n\n  // 5. Assign profile key based on the owner's name\n  let profileKey = 'kyle'; // Default fallback\n  if (ownerName === 'Hudson Lorfing') {\n    profileKey = 'hudson';\n  } else if (ownerName === 'Kyle Reagan') {\n    profileKey = 'kyle';\n  }\n  console.log(`Profile Key assigned: \"${profileKey}\"`);\n\n  // 6. Return the formatted result\n  return {\n    json: {\n      profile: profileKey,\n      owner: ownerName,\n      agentId: body.agentId || '',\n      containerId: body.containerId || '',\n      connectionCount: parsedResults.length\n    }\n  };\n});"
      },
      "id": "wf2v2r-parse-webhook",
      "name": "Parse Webhook",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5008,
        400
      ]
    },
    {
      "parameters": {
        "url": "={{ 'https://api.phantombuster.com/api/v2/agents/fetch-output?id=' + $json.agentId + '&containerId=' + $json.containerId }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {
          "timeout": 30000
        }
      },
      "id": "wf2v2r-fetch-result",
      "name": "Fetch PB Result",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5200,
        400
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "KWeabljbYSzoLpjI",
          "name": "Phantom Header Auth"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse PhantomBuster output â€” extract JSON URL + detect critical errors\nconst result = $input.first().json;\nconst profile = $('Parse Webhook').first().json.profile;\nconst output = result.output || '';\nconst outputLower = output.toLowerCase();\n\nlet isCriticalError = false;\nlet criticalErrorType = null;\nlet resultMessage = '';\n\n// Exit code\nconst exitCodeMatch = output.match(/exit code: (\\d+)/);\nconst exitCode = exitCodeMatch ? parseInt(exitCodeMatch[1]) : null;\n\n// Extract the JSON results URL from PB output\nconst jsonUrlMatch = output.match(/JSON saved at (https:\\/\\/[^\\s]+\\.json)/);\nconst jsonResultUrl = jsonUrlMatch ? jsonUrlMatch[1] : null;\n\n// Count processed profiles from output\nconst countMatch = output.match(/(\\d+) profiles? (?:have|has) been processed/);\nconst processedCount = countMatch ? parseInt(countMatch[1]) : 0;\n\n// CRITICAL ERROR DETECTION\nif (outputLower.includes('disconnected by linkedin')) {\n  isCriticalError = true;\n  criticalErrorType = 'DISCONNECTED';\n  resultMessage = 'Disconnected by LinkedIn - session may be flagged';\n} else if (outputLower.includes('no valid credentials') || outputLower.includes('invalid credentials') || exitCode === 87) {\n  isCriticalError = true;\n  criticalErrorType = 'INVALID_CREDENTIALS';\n  resultMessage = 'Invalid LinkedIn credentials - cookie needs refresh';\n} else if (outputLower.includes('session expired') || outputLower.includes('not logged in') || outputLower.includes('login required')) {\n  isCriticalError = true;\n  criticalErrorType = 'SESSION_EXPIRED';\n  resultMessage = 'LinkedIn session expired - need to re-authenticate';\n} else if (outputLower.includes('account restricted') || outputLower.includes('account suspended')) {\n  isCriticalError = true;\n  criticalErrorType = 'ACCOUNT_RESTRICTED';\n  resultMessage = 'LinkedIn account may be restricted';\n} else if (outputLower.includes('rate limit') || outputLower.includes('too many requests')) {\n  isCriticalError = true;\n  criticalErrorType = 'RATE_LIMITED';\n  resultMessage = 'LinkedIn rate limit reached';\n} else if (exitCode === 87 || (exitCode === 1 && processedCount === 0)) {\n  isCriticalError = true;\n  criticalErrorType = 'EXIT_CODE_ERROR';\n  resultMessage = `PhantomBuster error (exit code ${exitCode}) - possible credential issue`;\n} else if (!jsonResultUrl && result.status === 'finished' && exitCode === 0) {\n  resultMessage = 'Phantom finished but no JSON result URL found in output';\n} else {\n  resultMessage = `Processed ${processedCount} profile(s) successfully`;\n}\n\nreturn [{\n  json: {\n    profile,\n    jsonResultUrl,\n    processedCount,\n    sentDate: new Date().toISOString().split('T')[0],\n    isCriticalError,\n    criticalErrorType,\n    resultMessage,\n    _debug: {\n      phantomStatus: result.status,\n      exitCode,\n      outputSnippet: output.substring(output.length - 600)\n    }\n  }\n}];"
      },
      "id": "wf2v2r-parse-result",
      "name": "Parse Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5408,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "critical-error-check",
              "leftValue": "={{ $json.isCriticalError }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "wf2v2r-critical-check",
      "name": "Critical Error?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5600,
        400
      ]
    },
    {
      "parameters": {
        "select": "channel",
        "channelId": {
          "__rl": true,
          "mode": "id",
          "value": "C0A6ES56MU2"
        },
        "text": "={{ 'ðŸš¨ *LinkedIn Outreach STOPPED - Critical Error*\\n\\n*Error Type:* ' + $json.criticalErrorType + '\\n*Message:* ' + $json.resultMessage + '\\n*Profile:* ' + ($json.profile || 'unknown') + '\\n\\n*Action Required:* Check PhantomBuster credentials and LinkedIn session cookie.\\n\\n_Workflow has been stopped to prevent further issues. Please fix credentials and manually restart._' }}",
        "otherOptions": {}
      },
      "id": "wf2v2r-slack-error",
      "name": "Slack: Critical Error Alert",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.2,
      "position": [
        5808,
        288
      ],
      "webhookId": "ec31d7c3-1716-40c7-bf5a-97ed2cec6d2e",
      "credentials": {
        "slackApi": {
          "id": "wkLpZSqhXl2iesnC",
          "name": "Chrt Slack App"
        }
      }
    },
    {
      "parameters": {
        "errorMessage": "={{ 'Critical LinkedIn error: ' + $json.criticalErrorType + ' - ' + $json.resultMessage }}"
      },
      "id": "wf2v2r-stop-error",
      "name": "Stop Workflow (Critical Error)",
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [
        6000,
        288
      ]
    },
    {
      "parameters": {
        "url": "={{ $json.jsonResultUrl }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {
          "timeout": 30000
        }
      },
      "id": "wf2v2r-fetch-json",
      "name": "Fetch PB Results JSON",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        5808,
        528
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "KWeabljbYSzoLpjI",
          "name": "Phantom Header Auth"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Collect ALL PB result items into one updates array for batch POST\nconst allItems = $('Fetch PB Results JSON').all();\nconst profile = $('Parse Result').first().json.profile;\nconst sentDate = $('Parse Result').first().json.sentDate;\n\nconst updates = allItems.map(item => {\n  const r = item.json;\n  const url = r.linkedinProfileUrl || r.baseUrl || r.defaultProfileUrl || '';\n  let status = 'Request Sent';\n  if (r.error) {\n    status = r.error.includes('unavailable') ? 'Profile Not Found' : 'Error';\n  } else if (r.message && r.message.toLowerCase().includes('already connected')) {\n    status = 'Already Connected';\n  } else if (r.message && r.message.toLowerCase().includes('already invited')) {\n    status = 'Already Invited';\n  } else if (r.message && r.message.toLowerCase().includes('pending invitation')) {\n    status = 'Already Invited';\n  }\n  return { defaultProfileUrl: url, status, sentDate };\n}).filter(u => u.defaultProfileUrl);\n\nreturn [{ json: { profile, updates } }];"
      },
      "id": "wf2v2r-prepare-updates",
      "name": "Prepare Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6000,
        528
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://script.google.com/macros/s/AKfycbwNmYEcjOQd0Nj0Qr0cS6oZ3E15Th0E4WxTu0vV_lHHZ-fMd_B-xgSBxeYBupxGJDDl2A/exec",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ profile: $json.profile, updates: $json.updates }) }}",
        "options": {
          "redirect": {
            "redirect": {}
          },
          "timeout": 30000
        }
      },
      "id": "wf2v2r-batch-update",
      "name": "Batch Update Master List",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        6208,
        528
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "clear",
        "documentId": {
          "__rl": true,
          "value": "1xPgob7BwDoDGAOtDPBTvKzhQHl2FUZkJhJG0gEHWdgo",
          "mode": "list",
          "cachedResultName": "HoldingSheet",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1xPgob7BwDoDGAOtDPBTvKzhQHl2FUZkJhJG0gEHWdgo/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 2051829261,
          "mode": "list",
          "cachedResultName": "Sheet2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1xPgob7BwDoDGAOtDPBTvKzhQHl2FUZkJhJG0gEHWdgo/edit#gid=2051829261"
        },
        "clear": "specificRange",
        "range": "A2:A"
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        6400,
        528
      ],
      "id": "wf2v2r-clear-sheet",
      "name": "Clear HoldingSheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "hf9VoWnqYNXhUZsn",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ ok: true, message: 'Outreach results processed' }) }}",
        "options": {}
      },
      "id": "wf2v2r-respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        6608,
        528
      ]
    }
  ],
  "connections": {
    "PB Webhook": {
      "main": [
        [
          {
            "node": "Parse Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking 'Execute workflow'": {
      "main": [
        []
      ]
    },
    "Parse Webhook": {
      "main": [
        [
          {
            "node": "Fetch PB Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch PB Result": {
      "main": [
        [
          {
            "node": "Parse Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Result": {
      "main": [
        [
          {
            "node": "Critical Error?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Critical Error?": {
      "main": [
        [
          {
            "node": "Slack: Critical Error Alert",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch PB Results JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Slack: Critical Error Alert": {
      "main": [
        [
          {
            "node": "Stop Workflow (Critical Error)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch PB Results JSON": {
      "main": [
        [
          {
            "node": "Prepare Updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Updates": {
      "main": [
        [
          {
            "node": "Batch Update Master List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Update Master List": {
      "main": [
        [
          {
            "node": "Clear HoldingSheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear HoldingSheet": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": null,
  "versionId": "337c11a7-eebe-45f2-8508-1a0093ae6dde",
  "activeVersionId": "337c11a7-eebe-45f2-8508-1a0093ae6dde",
  "versionCounter": 5,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-02-10T00:42:44.360Z",
      "createdAt": "2026-02-10T00:42:44.360Z",
      "role": "workflow:owner",
      "workflowId": "ZUqVzkqYvfBjg6tj",
      "projectId": "O7lTivDfRl72aS23",
      "project": {
        "updatedAt": "2025-12-24T03:17:11.000Z",
        "createdAt": "2025-12-23T21:24:31.508Z",
        "id": "O7lTivDfRl72aS23",
        "name": "ChrtWorkflows",
        "type": "team",
        "icon": {
          "type": "icon",
          "value": "layers"
        },
        "description": "",
        "creatorId": null,
        "projectRelations": [
          {
            "updatedAt": "2025-12-23T21:24:31.510Z",
            "createdAt": "2025-12-23T21:24:31.510Z",
            "userId": "3f98abd2-ede1-4e1f-985d-ae50bbfbeda4",
            "projectId": "O7lTivDfRl72aS23",
            "user": {
              "updatedAt": "2026-02-10T08:00:55.000Z",
              "createdAt": "2025-12-17T12:51:53.118Z",
              "id": "3f98abd2-ede1-4e1f-985d-ae50bbfbeda4",
              "email": "hudson@chrt.com",
              "firstName": "Hudson",
              "lastName": "Lorfing",
              "personalizationAnswers": null,
              "settings": {
                "userActivated": true,
                "userClaimedAiCredits": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "kjjYKQEXv67Vl5MS",
                "userActivatedAt": 1766099344758,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1768855960435
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-10",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-10T05:43:25.000Z",
    "createdAt": "2026-02-10T00:42:43.717Z",
    "versionId": "337c11a7-eebe-45f2-8508-1a0093ae6dde",
    "workflowId": "ZUqVzkqYvfBjg6tj",
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "outreach-results",
          "responseMode": "responseNode",
          "options": {}
        },
        "id": "wf2v2r-webhook",
        "name": "PB Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          4800,
          400
        ],
        "webhookId": "d4e5f6a7-b8c9-4012-def3-456789abcdef"
      },
      {
        "parameters": {},
        "type": "n8n-nodes-base.manualTrigger",
        "typeVersion": 1,
        "position": [
          4800,
          608
        ],
        "id": "wf2v2r-manual",
        "name": "When clicking 'Execute workflow'"
      },
      {
        "parameters": {
          "jsCode": "const items = $input.all();\n\nreturn items.map((item, index) => {\n  // 1. Access the 'body' property where n8n stores webhook data\n  const body = item.json.body || {};\n  console.log(`--- Processing Webhook Item ${index} ---`);\n\n  // 2. Extract the resultObject string\n  const rawResult = body.resultObject || \"[]\";\n  \n  let parsedResults = [];\n  try {\n    // 3. Parse the string into a real array\n    parsedResults = JSON.parse(rawResult);\n    console.log(`Parsed ${parsedResults.length} connections from resultObject.`);\n  } catch (e) {\n    console.error(\"JSON Parse Error:\", e.message);\n  }\n\n  // 4. Get the owner from the first connection in the list\n  const firstConnection = parsedResults[0] || {};\n  const ownerName = firstConnection.inviterName || \"Unknown\";\n  console.log(`Detected Owner: \"${ownerName}\"`);\n\n  // 5. Assign profile key based on the owner's name\n  let profileKey = 'kyle'; // Default fallback\n  if (ownerName === 'Hudson Lorfing') {\n    profileKey = 'hudson';\n  } else if (ownerName === 'Kyle Reagan') {\n    profileKey = 'kyle';\n  }\n  console.log(`Profile Key assigned: \"${profileKey}\"`);\n\n  // 6. Return the formatted result\n  return {\n    json: {\n      profile: profileKey,\n      owner: ownerName,\n      agentId: body.agentId || '',\n      containerId: body.containerId || '',\n      connectionCount: parsedResults.length\n    }\n  };\n});"
        },
        "id": "wf2v2r-parse-webhook",
        "name": "Parse Webhook",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5008,
          400
        ]
      },
      {
        "parameters": {
          "url": "={{ 'https://api.phantombuster.com/api/v2/agents/fetch-output?id=' + $json.agentId + '&containerId=' + $json.containerId }}",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "options": {
            "timeout": 30000
          }
        },
        "id": "wf2v2r-fetch-result",
        "name": "Fetch PB Result",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          5200,
          400
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "KWeabljbYSzoLpjI",
            "name": "Phantom Header Auth"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Parse PhantomBuster output â€” extract JSON URL + detect critical errors\nconst result = $input.first().json;\nconst profile = $('Parse Webhook').first().json.profile;\nconst output = result.output || '';\nconst outputLower = output.toLowerCase();\n\nlet isCriticalError = false;\nlet criticalErrorType = null;\nlet resultMessage = '';\n\n// Exit code\nconst exitCodeMatch = output.match(/exit code: (\\d+)/);\nconst exitCode = exitCodeMatch ? parseInt(exitCodeMatch[1]) : null;\n\n// Extract the JSON results URL from PB output\nconst jsonUrlMatch = output.match(/JSON saved at (https:\\/\\/[^\\s]+\\.json)/);\nconst jsonResultUrl = jsonUrlMatch ? jsonUrlMatch[1] : null;\n\n// Count processed profiles from output\nconst countMatch = output.match(/(\\d+) profiles? (?:have|has) been processed/);\nconst processedCount = countMatch ? parseInt(countMatch[1]) : 0;\n\n// CRITICAL ERROR DETECTION\nif (outputLower.includes('disconnected by linkedin')) {\n  isCriticalError = true;\n  criticalErrorType = 'DISCONNECTED';\n  resultMessage = 'Disconnected by LinkedIn - session may be flagged';\n} else if (outputLower.includes('no valid credentials') || outputLower.includes('invalid credentials') || exitCode === 87) {\n  isCriticalError = true;\n  criticalErrorType = 'INVALID_CREDENTIALS';\n  resultMessage = 'Invalid LinkedIn credentials - cookie needs refresh';\n} else if (outputLower.includes('session expired') || outputLower.includes('not logged in') || outputLower.includes('login required')) {\n  isCriticalError = true;\n  criticalErrorType = 'SESSION_EXPIRED';\n  resultMessage = 'LinkedIn session expired - need to re-authenticate';\n} else if (outputLower.includes('account restricted') || outputLower.includes('account suspended')) {\n  isCriticalError = true;\n  criticalErrorType = 'ACCOUNT_RESTRICTED';\n  resultMessage = 'LinkedIn account may be restricted';\n} else if (outputLower.includes('rate limit') || outputLower.includes('too many requests')) {\n  isCriticalError = true;\n  criticalErrorType = 'RATE_LIMITED';\n  resultMessage = 'LinkedIn rate limit reached';\n} else if (exitCode === 87 || (exitCode === 1 && processedCount === 0)) {\n  isCriticalError = true;\n  criticalErrorType = 'EXIT_CODE_ERROR';\n  resultMessage = `PhantomBuster error (exit code ${exitCode}) - possible credential issue`;\n} else if (!jsonResultUrl && result.status === 'finished' && exitCode === 0) {\n  resultMessage = 'Phantom finished but no JSON result URL found in output';\n} else {\n  resultMessage = `Processed ${processedCount} profile(s) successfully`;\n}\n\nreturn [{\n  json: {\n    profile,\n    jsonResultUrl,\n    processedCount,\n    sentDate: new Date().toISOString().split('T')[0],\n    isCriticalError,\n    criticalErrorType,\n    resultMessage,\n    _debug: {\n      phantomStatus: result.status,\n      exitCode,\n      outputSnippet: output.substring(output.length - 600)\n    }\n  }\n}];"
        },
        "id": "wf2v2r-parse-result",
        "name": "Parse Result",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          5408,
          400
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 2
            },
            "conditions": [
              {
                "id": "critical-error-check",
                "leftValue": "={{ $json.isCriticalError }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "id": "wf2v2r-critical-check",
        "name": "Critical Error?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          5600,
          400
        ]
      },
      {
        "parameters": {
          "select": "channel",
          "channelId": {
            "__rl": true,
            "mode": "id",
            "value": "C0A6ES56MU2"
          },
          "text": "={{ 'ðŸš¨ *LinkedIn Outreach STOPPED - Critical Error*\\n\\n*Error Type:* ' + $json.criticalErrorType + '\\n*Message:* ' + $json.resultMessage + '\\n*Profile:* ' + ($json.profile || 'unknown') + '\\n\\n*Action Required:* Check PhantomBuster credentials and LinkedIn session cookie.\\n\\n_Workflow has been stopped to prevent further issues. Please fix credentials and manually restart._' }}",
          "otherOptions": {}
        },
        "id": "wf2v2r-slack-error",
        "name": "Slack: Critical Error Alert",
        "type": "n8n-nodes-base.slack",
        "typeVersion": 2.2,
        "position": [
          5808,
          288
        ],
        "webhookId": "ec31d7c3-1716-40c7-bf5a-97ed2cec6d2e",
        "credentials": {
          "slackApi": {
            "id": "wkLpZSqhXl2iesnC",
            "name": "Chrt Slack App"
          }
        }
      },
      {
        "parameters": {
          "errorMessage": "={{ 'Critical LinkedIn error: ' + $json.criticalErrorType + ' - ' + $json.resultMessage }}"
        },
        "id": "wf2v2r-stop-error",
        "name": "Stop Workflow (Critical Error)",
        "type": "n8n-nodes-base.stopAndError",
        "typeVersion": 1,
        "position": [
          6000,
          288
        ]
      },
      {
        "parameters": {
          "url": "={{ $json.jsonResultUrl }}",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "options": {
            "timeout": 30000
          }
        },
        "id": "wf2v2r-fetch-json",
        "name": "Fetch PB Results JSON",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          5808,
          528
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "KWeabljbYSzoLpjI",
            "name": "Phantom Header Auth"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// Collect ALL PB result items into one updates array for batch POST\nconst allItems = $('Fetch PB Results JSON').all();\nconst profile = $('Parse Result').first().json.profile;\nconst sentDate = $('Parse Result').first().json.sentDate;\n\nconst updates = allItems.map(item => {\n  const r = item.json;\n  const url = r.linkedinProfileUrl || r.baseUrl || r.defaultProfileUrl || '';\n  let status = 'Request Sent';\n  if (r.error) {\n    status = r.error.includes('unavailable') ? 'Profile Not Found' : 'Error';\n  } else if (r.message && r.message.toLowerCase().includes('already connected')) {\n    status = 'Already Connected';\n  } else if (r.message && r.message.toLowerCase().includes('already invited')) {\n    status = 'Already Invited';\n  } else if (r.message && r.message.toLowerCase().includes('pending invitation')) {\n    status = 'Already Invited';\n  }\n  return { defaultProfileUrl: url, status, sentDate };\n}).filter(u => u.defaultProfileUrl);\n\nreturn [{ json: { profile, updates } }];"
        },
        "id": "wf2v2r-prepare-updates",
        "name": "Prepare Updates",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          6000,
          528
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://script.google.com/macros/s/AKfycbwNmYEcjOQd0Nj0Qr0cS6oZ3E15Th0E4WxTu0vV_lHHZ-fMd_B-xgSBxeYBupxGJDDl2A/exec",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ profile: $json.profile, updates: $json.updates }) }}",
          "options": {
            "redirect": {
              "redirect": {}
            },
            "timeout": 30000
          }
        },
        "id": "wf2v2r-batch-update",
        "name": "Batch Update Master List",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          6208,
          528
        ],
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "operation": "clear",
          "documentId": {
            "__rl": true,
            "value": "1xPgob7BwDoDGAOtDPBTvKzhQHl2FUZkJhJG0gEHWdgo",
            "mode": "list",
            "cachedResultName": "HoldingSheet",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1xPgob7BwDoDGAOtDPBTvKzhQHl2FUZkJhJG0gEHWdgo/edit?usp=drivesdk"
          },
          "sheetName": {
            "__rl": true,
            "value": 2051829261,
            "mode": "list",
            "cachedResultName": "Sheet2",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1xPgob7BwDoDGAOtDPBTvKzhQHl2FUZkJhJG0gEHWdgo/edit#gid=2051829261"
          },
          "clear": "specificRange",
          "range": "A2:A"
        },
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          6400,
          528
        ],
        "id": "wf2v2r-clear-sheet",
        "name": "Clear HoldingSheet",
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "hf9VoWnqYNXhUZsn",
            "name": "Google Sheets account"
          }
        }
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ ok: true, message: 'Outreach results processed' }) }}",
          "options": {}
        },
        "id": "wf2v2r-respond",
        "name": "Respond to Webhook",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          6608,
          528
        ]
      }
    ],
    "connections": {
      "PB Webhook": {
        "main": [
          [
            {
              "node": "Parse Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "When clicking 'Execute workflow'": {
        "main": [
          []
        ]
      },
      "Parse Webhook": {
        "main": [
          [
            {
              "node": "Fetch PB Result",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch PB Result": {
        "main": [
          [
            {
              "node": "Parse Result",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Result": {
        "main": [
          [
            {
              "node": "Critical Error?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Critical Error?": {
        "main": [
          [
            {
              "node": "Slack: Critical Error Alert",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Fetch PB Results JSON",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Slack: Critical Error Alert": {
        "main": [
          [
            {
              "node": "Stop Workflow (Critical Error)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch PB Results JSON": {
        "main": [
          [
            {
              "node": "Prepare Updates",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Updates": {
        "main": [
          [
            {
              "node": "Batch Update Master List",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Batch Update Master List": {
        "main": [
          [
            {
              "node": "Clear HoldingSheet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Clear HoldingSheet": {
        "main": [
          [
            {
              "node": "Respond to Webhook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Hudson Lorfing",
    "name": "Version 337c11a7",
    "description": "",
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-10T05:43:25.437Z",
        "id": 507,
        "workflowId": "ZUqVzkqYvfBjg6tj",
        "versionId": "337c11a7-eebe-45f2-8508-1a0093ae6dde",
        "event": "activated",
        "userId": "3f98abd2-ede1-4e1f-985d-ae50bbfbeda4"
      }
    ]
  }
}
