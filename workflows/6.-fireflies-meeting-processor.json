{
  "name": "6. Fireflies Meeting Processor",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "fireflies-meeting",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "fireflies-webhook",
      "name": "Fireflies Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "fireflies-meeting"
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate Fireflies payload\nconst webhook = $input.first().json;\nconst body = webhook.body || webhook;\n\n// Check for duplicate - use meeting ID or transcript hash\nconst meetingId = body.meeting_id || body.id || '';\nconst title = body.title || 'Untitled Meeting';\nconst transcript = body.transcript || body.sentences?.map(s => `${s.speaker_name}: ${s.text}`).join('\\n') || '';\n\n// Create a simple hash for duplicate detection\nconst hash = require('crypto').createHash('md5').update(meetingId + title + transcript.substring(0, 500)).digest('hex').substring(0, 12);\n\n// Check transcript length for batching\nconst transcriptLength = transcript.length;\nconst estimatedTokens = Math.ceil(transcriptLength / 4); // rough estimate\nconst needsBatching = estimatedTokens > 30000; // Gemini Flash limit\n\nreturn [{\n  json: {\n    meetingId,\n    hash,\n    title,\n    date: body.date || body.dateString || new Date().toISOString(),\n    duration: body.duration || 0,\n    attendees: body.attendees || body.participants || [],\n    transcript,\n    transcriptLength,\n    estimatedTokens,\n    needsBatching,\n    firefliesUrl: body.transcript_url || '',\n    meetingUrl: body.meeting_url || body.video_url || '',\n    rawPayload: body\n  }\n}];"
      },
      "id": "extract-meeting",
      "name": "Extract Meeting Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose", "version": 2 },
          "conditions": [
            {
              "id": "has-transcript",
              "leftValue": "={{ $json.transcript.length }}",
              "rightValue": 100,
              "operator": { "type": "number", "operation": "gte" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-valid",
      "name": "Has Valid Transcript?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "select": "channel",
        "channelId": { "__rl": true, "mode": "id", "value": "C0A79PHB5JL" },
        "text": "üìù *New Meeting Transcript Ready*\n*Title:* {{ $json.title }}\n*Duration:* {{ Math.round($json.duration / 60) || 'Unknown' }} minutes\n*Transcript:* {{ $json.estimatedTokens.toLocaleString() }} tokens",
        "attachments": [],
        "blocksUi": {
          "blocksValues": [
            {
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "üìù *New Meeting Ready for Processing*\n*Title:* `{{ $json.title }}`\n*Duration:* {{ Math.round($json.duration / 60) || '?' }} min | *Tokens:* ~{{ $json.estimatedTokens.toLocaleString() }}"
              }
            },
            { "type": "divider" },
            {
              "type": "input",
              "element": {
                "type": "static_select",
                "action_id": "workspace_select",
                "placeholder": { "type": "plain_text", "text": "Select workspace" },
                "options": [
                  { "text": { "type": "plain_text", "text": "üè¢ Chrt" }, "value": "chrt" },
                  { "text": { "type": "plain_text", "text": "üí° GoodLux" }, "value": "goodlux" },
                  { "text": { "type": "plain_text", "text": "üè† Personal" }, "value": "personal" },
                  { "text": { "type": "plain_text", "text": "üõñ ShedPro" }, "value": "shedpro" }
                ]
              },
              "label": { "type": "plain_text", "text": "Which workspace?" }
            },
            {
              "type": "input",
              "element": {
                "type": "plain_text_input",
                "action_id": "meeting_purpose",
                "multiline": true,
                "placeholder": { "type": "plain_text", "text": "e.g., Discovery call with ACME Corp" }
              },
              "label": { "type": "plain_text", "text": "Meeting purpose?" }
            },
            {
              "type": "input",
              "element": {
                "type": "plain_text_input",
                "action_id": "focus_areas",
                "multiline": true,
                "placeholder": { "type": "plain_text", "text": "e.g., Action items, pain points, budget" }
              },
              "label": { "type": "plain_text", "text": "Focus areas? (optional)" },
              "optional": true
            },
            {
              "type": "actions",
              "elements": [
                { "type": "button", "text": { "type": "plain_text", "text": "‚ú® Process Meeting" }, "style": "primary", "action_id": "submit_meeting" },
                { "type": "button", "text": { "type": "plain_text", "text": "Skip" }, "action_id": "skip_meeting" }
              ]
            }
          ]
        },
        "otherOptions": { "includeLinkToWorkflow": false }
      },
      "id": "slack-prompt",
      "name": "Slack: Ask for Context",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [680, 200],
      "credentials": {
        "slackOAuth2Api": { "id": "EBe7rpazmQ7oFc5K", "name": "Slack account" }
      }
    },
    {
      "parameters": {
        "resume": "webhook",
        "options": {
          "webhookSuffix": "={{ 'slack-response-' + $json.hash }}"
        }
      },
      "id": "wait-slack",
      "name": "Wait for Slack Response",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [920, 200],
      "webhookId": "slack-response"
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose", "version": 2 },
          "conditions": [
            {
              "id": "not-skipped",
              "leftValue": "={{ $json.body?.actions?.find(a => a.action_id === 'skip_meeting') ? 'skipped' : 'process' }}",
              "rightValue": "process",
              "operator": { "type": "string", "operation": "equals" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-skipped",
      "name": "Skipped?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1160, 200]
    },
    {
      "parameters": {
        "jsCode": "// Combine original meeting data with Slack response\nconst meeting = $('Extract Meeting Data').first().json;\nconst slack = $input.first().json.body || $input.first().json;\n\n// Parse Slack state values\nconst state = slack.state?.values || {};\nlet workspace = 'chrt';\nlet purpose = '';\nlet focus = '';\n\nfor (const blockId in state) {\n  const block = state[blockId];\n  if (block.workspace_select) workspace = block.workspace_select.selected_option?.value || workspace;\n  if (block.meeting_purpose) purpose = block.meeting_purpose.value || '';\n  if (block.focus_areas) focus = block.focus_areas.value || '';\n}\n\n// Prepare attendee list\nconst attendees = meeting.attendees.map(a => a.name || a.displayName || a.email || 'Unknown').join(', ');\n\n// Build filename\nconst dateStr = new Date(meeting.date).toISOString().split('T')[0];\nconst safeTitle = meeting.title.replace(/[^a-zA-Z0-9 -]/g, '').trim().substring(0, 50);\nconst fileName = `${dateStr}: ${safeTitle}.md`;\n\n// Split transcript into batches if needed\nconst MAX_CHARS = 100000; // ~25k tokens\nlet transcriptBatches = [];\nif (meeting.transcript.length > MAX_CHARS) {\n  // Split by sentence boundaries\n  const sentences = meeting.transcript.split(/(?<=[.!?])\\s+/);\n  let currentBatch = '';\n  for (const sentence of sentences) {\n    if ((currentBatch + sentence).length > MAX_CHARS) {\n      transcriptBatches.push(currentBatch.trim());\n      currentBatch = sentence;\n    } else {\n      currentBatch += ' ' + sentence;\n    }\n  }\n  if (currentBatch.trim()) transcriptBatches.push(currentBatch.trim());\n} else {\n  transcriptBatches = [meeting.transcript];\n}\n\nreturn [{\n  json: {\n    ...meeting,\n    workspace,\n    folder: workspace,\n    purpose,\n    focusAreas: focus,\n    attendeeList: attendees,\n    dateStr,\n    fileName,\n    transcriptBatches,\n    batchCount: transcriptBatches.length,\n    needsBatching: transcriptBatches.length > 1\n  }\n}];"
      },
      "id": "prepare-data",
      "name": "Prepare Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://srv1230891.hstgr.cloud:3849/select-model",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ task: 'meeting_analysis', inputTokens: $json.estimatedTokens, needsStructuredOutput: true }) }}",
        "options": { "timeout": 10000 }
      },
      "id": "select-model",
      "name": "Select Best Gemini Model",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1640, 100],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Use selected model or fallback\nconst modelResponse = $input.first().json;\nconst prepData = $('Prepare Data').first().json;\n\nconst model = modelResponse.model || 'gemini-2.0-flash';\nconst reason = modelResponse.reason || 'Default selection';\n\nreturn [{\n  json: {\n    ...prepData,\n    selectedModel: model,\n    modelReason: reason\n  }\n}];"
      },
      "id": "apply-model",
      "name": "Apply Model Selection",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1880, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/{{ $json.selectedModel }}:generateContent?key=AIzaSyBYVujCEbmqmcHc_mH0OofmQISnzXiRQGg",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ contents: [{ parts: [{ text: `You are a meeting analysis expert. Analyze this meeting and create a structured Obsidian markdown note.\\n\\n**Meeting:**\\n- Title: ${$json.title}\\n- Date: ${$json.dateStr}\\n- Attendees: ${$json.attendeeList || 'Not specified'}\\n- Purpose: ${$json.purpose || 'Not specified'}\\n- Focus: ${$json.focusAreas || 'None'}\\n\\n**Transcript:**\\n${$json.transcriptBatches[0]}\\n\\n**Output this EXACT format:**\\n\\n---\\nup:\\n  - \"[[Calendar]]\"\\nin:\\n  - \"[[Meetings]]\"\\nrelated:\\ncreated: ${$json.dateStr}\\ntags:\\n  - meeting\\n---\\n# ${$json.title}\\n\\n> [One sentence summary]\\n\\n## Meeting Details\\n| | |\\n|---|---|\\n| **Date** | ${$json.dateStr} |\\n| **Attendees** | ${$json.attendeeList || 'Not recorded'} |\\n| **Duration** | ${Math.round($json.duration / 60) || '?'} min |\\n\\n## Summary\\n[3-4 sentence summary]\\n\\n## Key Points\\n- [Point 1]\\n- [Point 2]\\n\\n## Action Items\\n- [ ] [Action with owner] #hudson\\n\\n## Decisions\\n- [Decisions made]\\n\\n## Follow-up\\n- [Next steps]\\n\\n## Notes\\n[Additional details]` }] }], generationConfig: { temperature: 0.3, maxOutputTokens: 4096 } }) }}",
        "options": { "timeout": 120000 }
      },
      "id": "gemini-analyze",
      "name": "Gemini: Analyze Transcript",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2120, 100],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Extract and clean Gemini response\nconst gemini = $input.first().json;\nconst prep = $('Apply Model Selection').first().json;\n\n// Extract text from Gemini response\nlet content = '';\ntry {\n  content = gemini.candidates?.[0]?.content?.parts?.[0]?.text || '';\n} catch (e) {\n  content = '';\n}\n\nif (!content) {\n  throw new Error('Gemini returned empty response');\n}\n\n// Remove markdown code fences if present\ncontent = content.replace(/^```(?:markdown)?\\n?/gm, '').replace(/\\n?```$/gm, '').trim();\n\n// Ensure frontmatter\nif (!content.startsWith('---')) {\n  content = `---\\nup:\\n  - \"[[Calendar]]\"\\nin:\\n  - \"[[Meetings]]\"\\nrelated:\\ncreated: ${prep.dateStr}\\ntags:\\n  - meeting\\n---\\n\\n${content}`;\n}\n\nreturn [{\n  json: {\n    content,\n    folder: prep.folder,\n    fileName: prep.fileName,\n    workspace: prep.workspace,\n    title: prep.title,\n    date: prep.dateStr,\n    hash: prep.hash,\n    model: prep.selectedModel\n  }\n}];"
      },
      "id": "clean-output",
      "name": "Clean Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2360, 100]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://api.github.com/repos/hudsonlorfing/meeting-notes/contents/{{ $json.folder }}/{{ encodeURIComponent($json.fileName) }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ message: 'Add meeting: ' + $json.title + ' (' + $json.date + ')', content: Buffer.from($json.content).toString('base64'), branch: 'main' }) }}",
        "options": {}
      },
      "id": "github-commit",
      "name": "GitHub: Commit File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2600, 100],
      "credentials": {
        "githubApi": { "id": "QO1GzHuZN8K3xHku", "name": "GitHub account" }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "select": "channel",
        "channelId": { "__rl": true, "mode": "id", "value": "C0A79PHB5JL" },
        "text": "‚úÖ *Meeting processed!*\n\nüìù *{{ $('Prepare Data').first().json.title }}*\nüìÅ `{{ $('Prepare Data').first().json.workspace }}/{{ $('Prepare Data').first().json.fileName }}`\nü§ñ Model: {{ $('Apply Model Selection').first().json.selectedModel }}\n\n_Run `sync-meetings` to pull to Obsidian_"
      },
      "id": "slack-success",
      "name": "Slack: Success",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [2840, 0],
      "credentials": {
        "slackOAuth2Api": { "id": "EBe7rpazmQ7oFc5K", "name": "Slack account" }
      }
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "select": "channel",
        "channelId": { "__rl": true, "mode": "id", "value": "C0A79PHB5JL" },
        "text": "‚ö†Ô∏è *Error processing meeting*\n\n{{ $json.error || $json.message || 'Unknown error' }}\n\nCheck n8n execution logs."
      },
      "id": "slack-error",
      "name": "Slack: Error",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [2840, 200],
      "credentials": {
        "slackOAuth2Api": { "id": "EBe7rpazmQ7oFc5K", "name": "Slack account" }
      }
    },
    {
      "parameters": {},
      "id": "skipped-done",
      "name": "Skipped - Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1400, 300]
    },
    {
      "parameters": {},
      "id": "invalid-done",
      "name": "Invalid - Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [680, 400]
    }
  ],
  "connections": {
    "Fireflies Webhook": {
      "main": [[{ "node": "Extract Meeting Data", "type": "main", "index": 0 }]]
    },
    "Extract Meeting Data": {
      "main": [[{ "node": "Has Valid Transcript?", "type": "main", "index": 0 }]]
    },
    "Has Valid Transcript?": {
      "main": [
        [{ "node": "Slack: Ask for Context", "type": "main", "index": 0 }],
        [{ "node": "Invalid - Done", "type": "main", "index": 0 }]
      ]
    },
    "Slack: Ask for Context": {
      "main": [[{ "node": "Wait for Slack Response", "type": "main", "index": 0 }]]
    },
    "Wait for Slack Response": {
      "main": [[{ "node": "Skipped?", "type": "main", "index": 0 }]]
    },
    "Skipped?": {
      "main": [
        [{ "node": "Prepare Data", "type": "main", "index": 0 }],
        [{ "node": "Skipped - Done", "type": "main", "index": 0 }]
      ]
    },
    "Prepare Data": {
      "main": [[{ "node": "Select Best Gemini Model", "type": "main", "index": 0 }]]
    },
    "Select Best Gemini Model": {
      "main": [
        [{ "node": "Apply Model Selection", "type": "main", "index": 0 }],
        [{ "node": "Apply Model Selection", "type": "main", "index": 0 }]
      ]
    },
    "Apply Model Selection": {
      "main": [[{ "node": "Gemini: Analyze Transcript", "type": "main", "index": 0 }]]
    },
    "Gemini: Analyze Transcript": {
      "main": [
        [{ "node": "Clean Output", "type": "main", "index": 0 }],
        [{ "node": "Slack: Error", "type": "main", "index": 0 }]
      ]
    },
    "Clean Output": {
      "main": [[{ "node": "GitHub: Commit File", "type": "main", "index": 0 }]]
    },
    "GitHub: Commit File": {
      "main": [
        [{ "node": "Slack: Success", "type": "main", "index": 0 }],
        [{ "node": "Slack: Error", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "YWP69Qgq0ZlCN7Gj"
  },
  "tags": []
}
