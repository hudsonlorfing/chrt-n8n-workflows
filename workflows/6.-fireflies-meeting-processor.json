{
  "name": "6. Fireflies Meeting Processor",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "fireflies-meeting",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "fireflies-webhook",
      "name": "Fireflies Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "fireflies-meeting"
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate Fireflies payload\nconst webhook = $input.first().json;\nconst body = webhook.body || webhook;\n\nconst meetingId = body.meeting_id || body.id || '';\nconst title = body.title || 'Untitled Meeting';\nconst transcript = body.transcript || body.sentences?.map(s => `${s.speaker_name}: ${s.text}`).join('\\n') || '';\n\n// Hash for duplicate detection\nconst hash = require('crypto').createHash('md5').update(meetingId + title + transcript.substring(0, 500)).digest('hex').substring(0, 12);\n\n// Token estimation\nconst transcriptLength = transcript.length;\nconst estimatedTokens = Math.ceil(transcriptLength / 4);\n\n// Auto-detect workspace from title/attendees\nlet workspace = 'chrt'; // default\nconst titleLower = title.toLowerCase();\nif (titleLower.includes('goodlux') || titleLower.includes('light')) workspace = 'goodlux';\nelse if (titleLower.includes('shed') || titleLower.includes('shedpro')) workspace = 'shedpro';\nelse if (titleLower.includes('personal') || titleLower.includes('family')) workspace = 'personal';\n\n// Attendees\nconst attendees = (body.attendees || body.participants || []).map(a => a.name || a.displayName || a.email || 'Unknown').join(', ');\n\n// Filename\nconst dateStr = new Date(body.date || body.dateString || new Date()).toISOString().split('T')[0];\nconst safeTitle = title.replace(/[^a-zA-Z0-9 -]/g, '').trim().substring(0, 50);\nconst fileName = `${dateStr}: ${safeTitle}.md`;\n\nreturn [{\n  json: {\n    meetingId,\n    hash,\n    title,\n    date: body.date || body.dateString || new Date().toISOString(),\n    dateStr,\n    duration: body.duration || 0,\n    attendees,\n    transcript,\n    transcriptLength,\n    estimatedTokens,\n    workspace,\n    folder: workspace,\n    fileName,\n    firefliesUrl: body.transcript_url || '',\n    rawPayload: body\n  }\n}];"
      },
      "id": "extract-meeting",
      "name": "Extract Meeting Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "loose", "version": 2 },
          "conditions": [
            {
              "id": "has-transcript",
              "leftValue": "={{ $json.transcript.length }}",
              "rightValue": 100,
              "operator": { "type": "number", "operation": "gte" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-valid",
      "name": "Has Valid Transcript?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_MEETINGS_WEBHOOK }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ text: 'üìù *Processing Meeting...*\\n*Title:* ' + $json.title + '\\n*Duration:* ' + Math.round($json.duration / 60) + ' min\\n*Tokens:* ~' + $json.estimatedTokens.toLocaleString() + '\\n*Workspace:* ' + $json.workspace }) }}",
        "options": { "timeout": 10000 }
      },
      "id": "slack-start",
      "name": "Slack: Processing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [660, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://srv1230891.hstgr.cloud:3849/select-model",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ task: 'meeting_analysis', inputTokens: $json.estimatedTokens }) }}",
        "options": { "timeout": 10000 }
      },
      "id": "select-model",
      "name": "Select Gemini Model",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 200],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Apply model selection\nconst modelResponse = $input.first().json;\nconst meeting = $('Extract Meeting Data').first().json;\n\nconst model = modelResponse.model || 'gemini-2.0-flash';\n\nreturn [{\n  json: {\n    ...meeting,\n    selectedModel: model,\n    modelReason: modelResponse.reason || 'Default'\n  }\n}];"
      },
      "id": "apply-model",
      "name": "Apply Model",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1140, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/{{ $json.selectedModel }}:generateContent?key=AIzaSyBYVujCEbmqmcHc_mH0OofmQISnzXiRQGg",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ contents: [{ parts: [{ text: 'You are a meeting analysis expert. Create a structured Obsidian markdown note.\\n\\n**Meeting:**\\n- Title: ' + $json.title + '\\n- Date: ' + $json.dateStr + '\\n- Attendees: ' + ($json.attendees || 'Not specified') + '\\n\\n**Transcript:**\\n' + $json.transcript.substring(0, 80000) + '\\n\\n**Output this EXACT format:**\\n\\n---\\nup:\\n  - \"[[Calendar]]\"\\nin:\\n  - \"[[Meetings]]\"\\nrelated:\\ncreated: ' + $json.dateStr + '\\ntags:\\n  - meeting\\n---\\n# ' + $json.title + '\\n\\n> [One sentence summary]\\n\\n## Meeting Details\\n| | |\\n|---|---|\\n| **Date** | ' + $json.dateStr + ' |\\n| **Attendees** | ' + ($json.attendees || 'Not recorded') + ' |\\n| **Duration** | ' + (Math.round($json.duration / 60) || '?') + ' min |\\n\\n## Summary\\n[3-4 sentence summary]\\n\\n## Key Points\\n- [Point 1]\\n- [Point 2]\\n\\n## Action Items\\n- [ ] [Action with owner] #hudson\\n\\n## Decisions\\n- [Decisions made]\\n\\n## Follow-up\\n- [Next steps]\\n\\n## Notes\\n[Additional details]' }] }], generationConfig: { temperature: 0.3, maxOutputTokens: 4096 } }) }}",
        "options": { "timeout": 120000 }
      },
      "id": "gemini-analyze",
      "name": "Gemini: Analyze",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1380, 200],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Extract and clean Gemini response\nconst gemini = $input.first().json;\nconst meeting = $('Apply Model').first().json;\n\nlet content = '';\ntry {\n  content = gemini.candidates?.[0]?.content?.parts?.[0]?.text || '';\n} catch (e) {\n  throw new Error('Gemini parsing error: ' + e.message);\n}\n\nif (!content) {\n  throw new Error('Gemini returned empty response');\n}\n\n// Clean markdown fences\ncontent = content.replace(/^```(?:markdown)?\\n?/gm, '').replace(/\\n?```$/gm, '').trim();\n\n// Ensure frontmatter\nif (!content.startsWith('---')) {\n  content = `---\\nup:\\n  - \"[[Calendar]]\"\\nin:\\n  - \"[[Meetings]]\"\\nrelated:\\ncreated: ${meeting.dateStr}\\ntags:\\n  - meeting\\n---\\n\\n${content}`;\n}\n\nreturn [{\n  json: {\n    content,\n    folder: meeting.folder,\n    fileName: meeting.fileName,\n    workspace: meeting.workspace,\n    title: meeting.title,\n    date: meeting.dateStr,\n    hash: meeting.hash,\n    model: meeting.selectedModel\n  }\n}];"
      },
      "id": "clean-output",
      "name": "Clean Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1620, 200]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://api.github.com/repos/hudsonlorfing/meeting-notes/contents/{{ $json.folder }}/{{ encodeURIComponent($json.fileName) }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "githubApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ message: 'Add meeting: ' + $json.title + ' (' + $json.date + ')', content: Buffer.from($json.content).toString('base64'), branch: 'main' }) }}",
        "options": {}
      },
      "id": "github-commit",
      "name": "GitHub: Commit",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1860, 200],
      "credentials": {
        "githubApi": { "id": "QO1GzHuZN8K3xHku", "name": "GitHub account" }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_MEETINGS_WEBHOOK }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ text: '‚úÖ *Meeting processed!*\\n\\nüìù *' + $json.title + '*\\nüìÅ `' + $json.workspace + '/' + $json.fileName + '`\\nü§ñ Model: ' + $json.model + '\\n\\n_Run `sync-meetings` to pull to Obsidian_' }) }}",
        "options": {}
      },
      "id": "slack-success",
      "name": "Slack: Success",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2100, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_MEETINGS_WEBHOOK }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ text: '‚ö†Ô∏è *Error processing meeting*\\n\\n' + ($json.error || $json.message || JSON.stringify($json).substring(0, 200)) + '\\n\\nCheck n8n execution logs.' }) }}",
        "options": {}
      },
      "id": "slack-error",
      "name": "Slack: Error",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2100, 300]
    },
    {
      "parameters": {},
      "id": "invalid-done",
      "name": "Invalid - Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [660, 400]
    }
  ],
  "connections": {
    "Fireflies Webhook": {
      "main": [[{ "node": "Extract Meeting Data", "type": "main", "index": 0 }]]
    },
    "Extract Meeting Data": {
      "main": [[{ "node": "Has Valid Transcript?", "type": "main", "index": 0 }]]
    },
    "Has Valid Transcript?": {
      "main": [
        [{ "node": "Slack: Processing", "type": "main", "index": 0 }],
        [{ "node": "Invalid - Done", "type": "main", "index": 0 }]
      ]
    },
    "Slack: Processing": {
      "main": [[{ "node": "Select Gemini Model", "type": "main", "index": 0 }]]
    },
    "Select Gemini Model": {
      "main": [
        [{ "node": "Apply Model", "type": "main", "index": 0 }],
        [{ "node": "Apply Model", "type": "main", "index": 0 }]
      ]
    },
    "Apply Model": {
      "main": [[{ "node": "Gemini: Analyze", "type": "main", "index": 0 }]]
    },
    "Gemini: Analyze": {
      "main": [
        [{ "node": "Clean Output", "type": "main", "index": 0 }],
        [{ "node": "Slack: Error", "type": "main", "index": 0 }]
      ]
    },
    "Clean Output": {
      "main": [[{ "node": "GitHub: Commit", "type": "main", "index": 0 }]]
    },
    "GitHub: Commit": {
      "main": [
        [{ "node": "Slack: Success", "type": "main", "index": 0 }],
        [{ "node": "Slack: Error", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "tags": []
}
