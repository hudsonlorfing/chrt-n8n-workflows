{
  "updatedAt": "2026-02-14T00:19:20.868Z",
  "createdAt": "2026-01-05T08:02:39.361Z",
  "id": "0PjeQ9VgbUgE5lnD",
  "name": "7. Slack Interaction Handler",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "meeting-intel-action",
        "responseMode": "responseNode",
        "options": {}
      },
      "name": "Slack Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        300
      ],
      "webhookId": "meeting-intel-action",
      "id": "0596aabe-a9ad-44e6-9403-e995277cf753"
    },
    {
      "parameters": {
        "jsCode": "// Parse Slack interaction payload ‚Äî Chrt-only (no workspace override)\nconst body = $input.first().json.body;\nlet payload;\n\nif (typeof body === 'string') {\n  const decoded = decodeURIComponent(body.replace('payload=', ''));\n  payload = JSON.parse(decoded);\n} else if (body?.payload) {\n  payload = typeof body.payload === 'string' ? JSON.parse(body.payload) : body.payload;\n} else {\n  payload = body;\n}\n\nconst action = payload.actions?.[0] || {};\nconst hash = action.value || '';\nconst actionId = action.action_id || '';\nconst state = payload.state?.values || {};\n\nconst recordingType = state.recording_type_block?.recording_type_select?.selected_option?.value || 'normal';\nconst detailLevel = state.detail_level_block?.detail_level_select?.selected_option?.value || 'standard';\nconst additionalAttendees = state.additional_attendees_block?.additional_attendees_input?.value || '';\n\nconst selectedApps = state.apps_block?.apps_select?.selected_options || [];\nlet appsOverride = null;\nif (selectedApps.length > 0) {\n  const weight = 1.0 / selectedApps.length;\n  appsOverride = selectedApps.map(opt => ({ id: opt.value, weight: Math.round(weight * 100) / 100 }));\n}\n\nconst customContext = state.custom_context_block?.custom_context_input?.value || '';\nconst user = payload.user?.username || payload.user?.name || 'unknown';\nconst responseUrl = payload.response_url || '';\nconst messageTs = payload.message?.ts || null;\nconst channelId = (typeof payload.channel === 'object' ? payload.channel?.id : payload.channel) || null;\n\nreturn [{ json: { hash, actionId, recordingType, detailLevel, additionalAttendees, appsOverride, customContext, user, responseUrl, messageTs, channelId } }];"
      },
      "name": "Parse Slack Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        300
      ],
      "id": "888efc07-d4f8-4be4-acd8-dab28c361705"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ text: '‚è≥ Processing...' }) }}"
      },
      "name": "Respond to Slack",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        440,
        300
      ],
      "id": "5bcfe588-f93c-4a57-a9b1-5585675240d8"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "is-analyze-action",
              "leftValue": "={{ $json.actionId }}",
              "rightValue": "analyze_meeting_v2",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "name": "Is Analyze Action?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        660,
        300
      ],
      "id": "0bb56810-2d52-4e74-bcba-9972172177ae"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meetings?hash=eq.{{ $('Parse Slack Payload').first().json.hash }}&select=*",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "options": {}
      },
      "name": "Supabase: Get Meeting",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        200
      ],
      "credentials": {
        "supabaseApi": {
          "id": "HRBgSj7d6TFZA8kL",
          "name": "Supabase account 2"
        }
      },
      "onError": "continueErrorOutput",
      "id": "supabase-get-meeting-001"
    },
    {
      "parameters": {
        "jsCode": "// Extract meeting and merge with Slack overrides ‚Äî source-agnostic\nconst response = $input.first().json;\nconst meeting = Array.isArray(response) ? response[0] : response;\n\nif (!meeting || !meeting.hash) {\n  throw new Error('Meeting not found in Supabase');\n}\n\nconst slack = $('Parse Slack Payload').first().json;\nconst apps = slack.appsOverride || meeting.suggested_apps || [{ id: 'general-notes', weight: 1.0 }];\nconst recordingType = slack.recordingType || 'normal';\nconst detailLevel = slack.detailLevel || 'standard';\n\nlet finalAttendees = meeting.attendees_raw || '';\nif (slack.additionalAttendees) {\n  if (recordingType === 'singular') {\n    finalAttendees = slack.additionalAttendees;\n  } else {\n    finalAttendees = finalAttendees ? finalAttendees + ', ' + slack.additionalAttendees : slack.additionalAttendees;\n  }\n}\n\nreturn [{ json: {\n  meetingId: meeting.source_id,\n  sourceType: meeting.source_type || 'fireflies',\n  meetingUuid: meeting.id,\n  hash: meeting.hash,\n  title: meeting.title,\n  personName: meeting.person_name,\n  meetingDate: meeting.meeting_date,\n  dateStr: meeting.date_str,\n  durationMins: meeting.duration_mins,\n  attendees: finalAttendees,\n  sourceUrl: meeting.source_url,\n  sourceSummary: meeting.source_summary,\n  transcriptRaw: meeting.transcript_raw,\n  isExternal: meeting.is_external,\n  meetingType: meeting.meeting_type,\n  slackThreadTs: meeting.slack_thread_ts,\n  slackChannelId: meeting.slack_channel_id || slack.channelId || 'C0AE7NPAWDQ',\n  messageTs: slack.messageTs,\n  channelId: slack.channelId || meeting.slack_channel_id || 'C0AE7NPAWDQ',\n  finalApps: apps,\n  recordingType,\n  detailLevel,\n  additionalAttendees: slack.additionalAttendees || '',\n  customContext: slack.customContext,\n  user: slack.user,\n  responseUrl: slack.responseUrl\n} }];"
      },
      "name": "Merge Overrides",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        200
      ],
      "id": "eb55be27-c15a-41f4-9a79-8766794eeb03"
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meetings?hash=eq.{{ $('Parse Slack Payload').first().json.hash }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Prefer",
              "value": "return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ status: 'processing' }) }}",
        "options": {}
      },
      "name": "Supabase: Mark Processing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1320,
        200
      ],
      "credentials": {
        "supabaseApi": {
          "id": "HRBgSj7d6TFZA8kL",
          "name": "Supabase account 2"
        }
      },
      "id": "supabase-mark-processing-001"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Parse Slack Payload').first().json.responseUrl }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ replace_original: true, text: '‚è≥ *Analyzing:* ' + $('Merge Overrides').first().json.title + '\\n\\nü§ñ Using: ' + $('Merge Overrides').first().json.finalApps.map(a => a.id + ' (' + Math.round(a.weight * 100) + '%)').join(', ') }) }}",
        "options": {}
      },
      "name": "Slack: Processing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1540,
        200
      ],
      "id": "f24eb243-1bca-485f-acc2-c35205305936"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "is-granola",
              "leftValue": "={{ $('Merge Overrides').first().json.sourceType }}",
              "rightValue": "granola",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "name": "Is Granola?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1760,
        200
      ],
      "id": "is-granola-check-001"
    },
    {
      "parameters": {
        "jsCode": "// Process Granola transcript from stored transcript_raw\nconst merged = $('Merge Overrides').first().json;\nconst transcriptRaw = merged.transcriptRaw;\n\nif (!transcriptRaw || !Array.isArray(transcriptRaw) || transcriptRaw.length === 0) {\n  throw new Error('No stored transcript_raw found for Granola meeting: ' + merged.meetingId);\n}\n\n// Speaker inference (same logic as WF6)\nconst chrtDomains = ['chrt.com', 'getchrt.com'];\nconst attendeeList = (merged.attendees || '').split(',').map(a => a.trim()).filter(Boolean);\nconst participantEmails = attendeeList.filter(a => a.includes('@'));\nconst externals = participantEmails.filter(e => !chrtDomains.some(d => e.toLowerCase().includes(d)));\nconst internals = participantEmails.filter(e => chrtDomains.some(d => e.toLowerCase().includes(d)));\nconst isOneOnOne = externals.length === 1;\n\n// Determine speaker labels\nconst ownerEmail = internals[0] || '';\nconst ownerName = merged.personName ? '' : '';\n// For Chrt rep: use known names or email prefix\nlet chrtLabel = 'Chrt Rep';\nif (ownerEmail) {\n  const prefix = ownerEmail.split('@')[0];\n  chrtLabel = prefix.charAt(0).toUpperCase() + prefix.slice(1);\n}\n\nlet externalLabel = 'External';\nif (isOneOnOne && externals[0]) {\n  const prefix = externals[0].split('@')[0].split('.');\n  externalLabel = prefix.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ');\n}\n\nconst transcriptLines = transcriptRaw.map(seg => {\n  const ts = seg.start_time\n    ? new Date(seg.start_time).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })\n    : '';\n  const timePrefix = ts ? `[${ts}] ` : '';\n\n  if (seg.speaker && seg.speaker.source === 'microphone') {\n    return `${timePrefix}[Chrt - ${chrtLabel}]: ${seg.text}`;\n  } else if (isOneOnOne) {\n    return `${timePrefix}[External - ${externalLabel}]: ${seg.text}`;\n  } else {\n    return `${timePrefix}[External]: ${seg.text}`;\n  }\n});\n\nconst transcriptText = transcriptLines.join('\\n');\n\nreturn [{ json: {\n  ...merged,\n  transcript: transcriptText,\n  transcriptLength: transcriptText.length,\n  participantEmails\n} }];"
      },
      "name": "Process Granola Transcript",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1980,
        100
      ],
      "id": "process-granola-transcript-001"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.fireflies.ai/graphql",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ query: `{ transcript(id: \"${$('Merge Overrides').first().json.meetingId}\") { id title date duration organizer_email participants sentences { speaker_name text } summary { overview } } }` }) }}",
        "options": {
          "timeout": 60000,
          "retry": {
            "enabled": true,
            "maxRetries": 2,
            "waitBetweenRetries": 5000
          }
        }
      },
      "name": "Fireflies: Re-Fetch Transcript (Legacy)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1980,
        300
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "E59l4LdE1u7lD39v",
          "name": "Fireflies API"
        }
      },
      "onError": "continueErrorOutput",
      "id": "fireflies-refetch-001"
    },
    {
      "parameters": {
        "jsCode": "// Extract transcript text from re-fetched Fireflies data (legacy path)\nconst response = $input.first().json;\nconst transcript = response.data?.transcript;\n\nif (!transcript) {\n  throw new Error('Transcript re-fetch failed: ' + JSON.stringify(response.errors || response).substring(0, 200));\n}\n\nconst transcriptText = (transcript.sentences || []).map(s => `${s.speaker_name}: ${s.text}`).join('\\n');\nconst merged = $('Merge Overrides').first().json;\n\n// Extract emails from attendees for Apps Script context resolution\nconst attendeeList = (merged.attendees || '').split(',').map(a => a.trim()).filter(Boolean);\nconst participantEmails = attendeeList.filter(a => a.includes('@'));\n\nreturn [{ json: {\n  ...merged,\n  transcript: transcriptText,\n  transcriptLength: transcriptText.length,\n  participantEmails\n} }];"
      },
      "name": "Process Fireflies Transcript (Legacy)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        300
      ],
      "id": "process-refetch-001"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://script.google.com/macros/s/AKfycbybWTFvdZnmPnQkndxAqA4jQQlMC2_gGMZOJULYk5ywyc0IPT2qNn7QIq5SAtC_jUJJRA/exec",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ action: 'resolve-context', participant_emails: $json.participantEmails, meeting_id: $json.meetingUuid }) }}",
        "options": {
          "timeout": 30000
        }
      },
      "name": "Apps Script: Resolve Context",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2200,
        200
      ],
      "continueOnFail": true,
      "id": "apps-script-resolve-context-001"
    },
    {
      "parameters": {
        "jsCode": "// Build AI Agent prompt with Chrt context, templates, and resolved context\n// Source-agnostic: works for both Granola and Fireflies transcript paths\nconst meeting = (() => {\n  try { return $('Process Granola Transcript').first().json; } catch(e) {}\n  try { return $('Process Fireflies Transcript (Legacy)').first().json; } catch(e) {}\n  throw new Error('No transcript data found from either Granola or Fireflies path');\n})();\nconst contextResponse = $input.first().json;\nconst resolvedContext = contextResponse.participants || [];\n\n// Build context injection\nlet contextBlock = '';\nif (resolvedContext.length > 0) {\n  contextBlock = '\\n\\n## Prior Context\\n';\n  resolvedContext.forEach(p => {\n    if (p.hubspot) {\n      contextBlock += `\\n### HubSpot: ${p.hubspot.firstname || ''} ${p.hubspot.lastname || ''}\\n`;\n      contextBlock += `- Company: ${p.hubspot.company || 'Unknown'}\\n`;\n      contextBlock += `- Title: ${p.hubspot.jobtitle || 'Unknown'}\\n`;\n      contextBlock += `- Stage: ${p.hubspot.lifecyclestage || 'Unknown'}\\n`;\n      if (p.hubspot.deals?.length > 0) {\n        contextBlock += `- Deals: ${p.hubspot.deals.map(d => d.name + ' (' + d.stage + ')').join(', ')}\\n`;\n      }\n      if (p.hubspot.last_spiced_score) {\n        contextBlock += `- Last SPICED Score: ${p.hubspot.last_spiced_score}\\n`;\n      }\n    }\n    if (p.prior_meetings?.length > 0) {\n      contextBlock += '\\n#### Prior Meetings:\\n';\n      p.prior_meetings.forEach(m => {\n        contextBlock += `- ${m.date}: ${m.title} (${m.type})\\n`;\n        if (m.summary) contextBlock += `  Summary: ${m.summary}\\n`;\n        if (m.scores) contextBlock += `  Scores: ${JSON.stringify(m.scores)}\\n`;\n      });\n    }\n    if (p.memory?.length > 0) {\n      contextBlock += '\\n#### Known Facts:\\n';\n      p.memory.forEach(f => {\n        contextBlock += `- [${f.type}] ${f.entity}: ${f.fact} (${f.confidence})\\n`;\n      });\n    }\n  });\n}\n\n// Build template instructions from apps\nconst apps = meeting.finalApps || [{id: 'general-notes', weight: 1.0}];\nconst templateInstructions = apps.map(a =>\n  `Analyze using template: ${a.id} (weight: ${Math.round(a.weight * 100)}%)`\n).join('\\n');\n\nconst systemPrompt = `You are Chrt's meeting intelligence analyst. Chrt is a B2B SaaS company selling real-time visibility and coordination software for time-critical logistics (medical, aerospace, industrial).\n\nTeam: Hudson Lorfing (CEO), Aaron Carver (Sales), Kyle Reagan (Sales).\nMethodology: SPICED framework.\nCustomer segments: Shippers (labs, hospitals, manufacturers), Couriers (last-mile delivery), Forwarders (3PLs, freight brokers).\n\nYour task: Analyze the meeting transcript and produce structured intelligence.\n\n${templateInstructions}\n\nOutput your analysis as structured JSON with these fields:\n- summary: 2-3 sentence executive summary\n- key_points: array of key discussion points\n- action_items: array of {owner, task, due} objects\n- decisions: array of decisions made\n- follow_ups: array of follow-up items\n- key_quotes: array of {speaker, text} objects\n- scores: object with any applicable scorecard results\n- analysis: detailed markdown analysis following the template format\n\n${meeting.customContext ? '\\nAdditional context from user: ' + meeting.customContext : ''}\n${contextBlock}`;\n\nconst userMessage = `Meeting: ${meeting.title}\\nDate: ${meeting.dateStr}\\nDuration: ${meeting.durationMins} min\\nAttendees: ${meeting.attendees}\\nType: ${meeting.meetingType} (${meeting.isExternal ? 'External' : 'Internal'})\\n${meeting.recordingType === 'singular' ? 'Note: This is a singular recording (speaker was alone)' : ''}\\n${meeting.detailLevel === 'context' ? 'Note: User requested detailed/context-level notes' : ''}\\n\\n## Transcript\\n\\n${meeting.transcript}`;\n\nreturn [{ json: {\n  ...meeting,\n  systemPrompt,\n  userMessage,\n  resolvedContext\n} }];"
      },
      "name": "Build AI Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2420,
        200
      ],
      "id": "build-ai-prompt-001"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.userMessage }}",
        "options": {
          "systemMessage": "={{ $json.systemPrompt }}",
          "maxTokens": 8192,
          "temperature": 0.3
        }
      },
      "name": "AI Agent: Analyze Meeting",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        2640,
        200
      ],
      "id": "ai-agent-analyze-001"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-sonnet-4-5-20250929",
          "mode": "list",
          "cachedResultName": "Claude Sonnet 4.5"
        },
        "options": {
          "maxTokensToSample": 8192,
          "temperature": 0.3
        }
      },
      "name": "Anthropic Claude",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        2560,
        420
      ],
      "credentials": {
        "anthropicApi": {
          "id": "B6k4mmzjw7OzEK5c",
          "name": "Anthropic account"
        }
      },
      "id": "anthropic-claude-001"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Build AI Prompt').first().json.slackThreadTs || $('Build AI Prompt').first().json.meetingUuid }}"
      },
      "name": "Window Buffer Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        2720,
        420
      ],
      "id": "window-buffer-memory-001"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and build structured output\nconst aiResponse = $input.first().json;\nconst meeting = $('Build AI Prompt').first().json;\nconst output = aiResponse.output || aiResponse.text || '';\n\n// Try to parse structured JSON from the response\nlet structuredData = {};\nlet analysisOutput = output;\n\ntry {\n  // Look for JSON block in the response\n  const jsonMatch = output.match(/```json\\n([\\s\\S]*?)\\n```/) || output.match(/\\{[\\s\\S]*\"summary\"[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    const jsonStr = jsonMatch[1] || jsonMatch[0];\n    structuredData = JSON.parse(jsonStr);\n    // Extract the analysis markdown if separate from JSON\n    analysisOutput = structuredData.analysis || output.replace(/```json[\\s\\S]*?```/, '').trim() || output;\n  } else {\n    // Build minimal structured data from plain text\n    structuredData = {\n      summary: output.substring(0, 500),\n      key_points: [],\n      action_items: [],\n      decisions: [],\n      follow_ups: [],\n      key_quotes: []\n    };\n    analysisOutput = output;\n  }\n} catch (e) {\n  console.log('Could not parse structured JSON: ' + e.message);\n  structuredData = { summary: output.substring(0, 500) };\n  analysisOutput = output;\n}\n\nconst scores = structuredData.scores || null;\n\n// Build Obsidian-compatible markdown\nconst dateStr = meeting.dateStr || new Date().toISOString().split('T')[0];\nconst personName = (meeting.personName || 'Team').replace(/[^a-zA-Z0-9 -]/g, '').trim();\nconst displayTitle = `${dateStr}Íûâ Meeting with ${personName}`;\nconst filePath = `chrt/${displayTitle}.md`;\n\nconst attendeeList = (meeting.attendees || '').split(',').map(a => a.trim()).filter(Boolean);\nconst participantLinks = attendeeList.filter(a => !a.toLowerCase().includes('hudson')).map(a => {\n  const name = a.includes('@') ? a.split('@')[0].split('.').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ') : a;\n  return `\"[[üë§${name.replace(/[^a-zA-Z0-9 -]/g, '').trim()}]]\"`;\n});\n\nconst appsUsed = (meeting.finalApps || []).map(a => a.id).join(', ');\nconst frontmatter = `---\\nup: \\nin:\\n  - \"[[Meetings]]\"\\nrelated: \\ncreated: ${dateStr}\\ntags:\\n  - meeting\\n  - chrt\\nmeeting_date: ${dateStr}\\nmeeting_with: \"[[üë§${personName}]]\"\\nparticipants:\\n${participantLinks.map(p => `  - ${p}`).join('\\n')}\\nanalysis_apps: [${appsUsed}]\\nmodel: claude-sonnet\\nprocessed_by: ${meeting.user}\\none-liner: \\n---\\n\\n# ${displayTitle}\\n*Meeting on ${dateStr}*\\n\\n## Participants\\n${participantLinks.map(p => `- ${p}`).join('\\n')}\\n\\n`;\n\nconst fullContent = frontmatter + analysisOutput;\n\nconst primaryEmail = attendeeList.find(a => a.includes('@') && !a.includes('chrt.com')) || '';\n\n// Extract token usage from AI agent response\nconst tokenUsage = aiResponse.tokenUsage || {};\nconst promptTokens = tokenUsage.promptTokens || 0;\nconst completionTokens = tokenUsage.completionTokens || 0;\nconst totalTokens = tokenUsage.totalTokens || (promptTokens + completionTokens);\n\nreturn [{ json: {\n  hash: meeting.hash,\n  meetingUuid: meeting.meetingUuid,\n  filePath,\n  fileName: displayTitle + '.md',\n  content: fullContent,\n  analysisOutput,\n  structuredData,\n  scores,\n  title: meeting.title,\n  displayTitle,\n  date: dateStr,\n  primaryEmail,\n  personName,\n  apps: meeting.finalApps,\n  model: 'claude-sonnet',\n  responseUrl: meeting.responseUrl,\n  slackThreadTs: meeting.slackThreadTs,\n  slackChannelId: meeting.slackChannelId,\n  messageTs: meeting.messageTs,\n  channelId: meeting.channelId || meeting.slackChannelId,\n  isExternal: meeting.isExternal,\n  participantEmails: meeting.participantEmails || [],\n  resolvedContext: meeting.resolvedContext || [],\n  promptTokens,\n  completionTokens,\n  totalTokens\n} }];"
      },
      "name": "Prepare Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2860,
        200
      ],
      "id": "85d82602-7181-405b-a39b-fe391f0e2567"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/agent_conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Prefer",
              "value": "return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify([ { session_id: $('Prepare Content').first().json.slackThreadTs || $('Prepare Content').first().json.meetingUuid || 'unknown', role: 'system', content: 'Analysis of: ' + $('Prepare Content').first().json.title + ' (' + $('Prepare Content').first().json.date + ')' }, { session_id: $('Prepare Content').first().json.slackThreadTs || $('Prepare Content').first().json.meetingUuid || 'unknown', role: 'assistant', content: ($('Prepare Content').first().json.structuredData?.summary || $('Prepare Content').first().json.analysisOutput || '').substring(0, 4000) } ]) }}",
        "options": {}
      },
      "name": "Supabase: Save Conversation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2940,
        100
      ],
      "credentials": {
        "supabaseApi": {
          "id": "HRBgSj7d6TFZA8kL",
          "name": "Supabase account 2"
        }
      },
      "continueOnFail": true,
      "id": "supabase-save-conversation-001"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meeting_analyses",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Prefer",
              "value": "return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ meeting_id: $('Prepare Content').first().json.meetingUuid, template_id: ($('Prepare Content').first().json.apps && $('Prepare Content').first().json.apps[0]) ? $('Prepare Content').first().json.apps[0].id : 'general-notes', analysis_output: $('Prepare Content').first().json.analysisOutput, structured_data: $('Prepare Content').first().json.structuredData, scores: $('Prepare Content').first().json.scores, model_used: $('Prepare Content').first().json.model, token_count: $('Prepare Content').first().json.totalTokens || 0, created_by: $('Prepare Content').first().json.personName || 'system' }) }}",
        "options": {}
      },
      "name": "Supabase: Store Analysis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3080,
        200
      ],
      "credentials": {
        "supabaseApi": {
          "id": "HRBgSj7d6TFZA8kL",
          "name": "Supabase account 2"
        }
      },
      "id": "supabase-store-analysis-001"
    },
    {
      "parameters": {
        "jsCode": "// Extract analysis ID from Supabase response, update meeting status\nconst analysisResp = $input.first().json;\nconst analysisId = Array.isArray(analysisResp) ? analysisResp[0]?.id : analysisResp?.id;\nconst prep = $('Prepare Content').first().json;\n\nreturn [{ json: { ...prep, analysisId } }];"
      },
      "name": "Get Analysis ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3300,
        200
      ],
      "id": "get-analysis-id-001"
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meetings?hash=eq.{{ $json.hash }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Prefer",
              "value": "return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ status: 'completed' }) }}",
        "options": {}
      },
      "name": "Supabase: Mark Completed",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3520,
        200
      ],
      "credentials": {
        "supabaseApi": {
          "id": "HRBgSj7d6TFZA8kL",
          "name": "Supabase account 2"
        }
      },
      "id": "supabase-mark-completed-001"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://script.google.com/macros/s/AKfycbybWTFvdZnmPnQkndxAqA4jQQlMC2_gGMZOJULYk5ywyc0IPT2qNn7QIq5SAtC_jUJJRA/exec",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ action: 'extract-memory', analysis_id: $('Get Analysis ID').first().json.analysisId, meeting_id: $('Prepare Content').first().json.meetingUuid, structured_data: $('Prepare Content').first().json.structuredData, participants: ($('Prepare Content').first().json.participantEmails || []).map(e => ({ email: e })) }) }}",
        "options": {
          "timeout": 30000
        }
      },
      "name": "Apps Script: Extract Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3740,
        200
      ],
      "continueOnFail": true,
      "id": "apps-script-extract-memory-001"
    },
    {
      "parameters": {
        "resource": "file",
        "operation": "create",
        "owner": {
          "__rl": true,
          "mode": "name",
          "value": "hudsonlorfing"
        },
        "repository": {
          "__rl": true,
          "mode": "name",
          "value": "meeting-notes"
        },
        "filePath": "={{ $('Prepare Content').first().json.filePath }}",
        "fileContent": "={{ $('Prepare Content').first().json.content }}",
        "commitMessage": "={{ 'Add meeting (chrt): ' + $('Prepare Content').first().json.displayTitle }}",
        "additionalParameters": {}
      },
      "name": "GitHub: Commit Meeting",
      "type": "n8n-nodes-base.github",
      "typeVersion": 1.1,
      "position": [
        3960,
        200
      ],
      "credentials": {
        "githubApi": {
          "id": "yiGNsTvCmOQmaC7f",
          "name": "GitHub PAT - Workflows"
        }
      },
      "continueOnFail": true,
      "id": "1e533e25-de72-4708-b3da-53c08e4d4438"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/contacts/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ filterGroups: [{ filters: [{ propertyName: 'email', operator: 'CONTAINS_TOKEN', value: $('Prepare Content').first().json.primaryEmail || '*' }] }], properties: ['email', 'firstname', 'lastname', 'company'] }) }}",
        "options": {}
      },
      "name": "HubSpot: Search Contact",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4180,
        100
      ],
      "credentials": {
        "hubspotOAuth2Api": {
          "id": "3JZVnZQkHgMfXMRx",
          "name": "HubSpot account"
        }
      },
      "continueOnFail": true,
      "id": "bd950bbe-0e54-4b30-b4c7-ab91df0e4c0e"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "has-contact",
              "leftValue": "={{ $json.results?.length > 0 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "name": "Has Contact?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4400,
        100
      ],
      "id": "16a7a1d2-1ea2-48d7-875e-4cf57ebaa34d"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/notes",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ properties: { hs_note_body: '## Meeting Intel: ' + $('Prepare Content').first().json.title + '\\n\\n**Analysis Apps:** ' + ($('Prepare Content').first().json.apps || []).map(a => a.id).join(', ') + '\\n**Date:** ' + $('Prepare Content').first().json.date + '\\n**Type:** ' + ($('Prepare Content').first().json.isExternal ? 'External' : 'Internal') + '\\n\\n' + ($('Prepare Content').first().json.structuredData?.summary || 'See full analysis') + '\\n\\n### Key Points\\n' + ($('Prepare Content').first().json.structuredData?.key_points || []).map(p => '- ' + p).join('\\n') + '\\n\\n### Action Items\\n' + ($('Prepare Content').first().json.structuredData?.action_items || []).map(a => '- ' + (a.owner || '') + ': ' + (a.task || a)).join('\\n') + '\\n\\n[View Full Analysis](https://github.com/hudsonlorfing/meeting-notes/blob/main/' + encodeURIComponent($('Prepare Content').first().json.filePath) + ')', hs_timestamp: new Date($('Prepare Content').first().json.date).getTime() }, associations: [{ to: { id: $('HubSpot: Search Contact').first().json.results[0].id }, types: [{ associationCategory: 'HUBSPOT_DEFINED', associationTypeId: 10 }] }] }) }}",
        "options": {}
      },
      "name": "HubSpot: Create Note",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4620,
        0
      ],
      "credentials": {
        "hubspotOAuth2Api": {
          "id": "3JZVnZQkHgMfXMRx",
          "name": "HubSpot account"
        }
      },
      "continueOnFail": true,
      "id": "91c468a4-1409-4c34-8113-15915be88b1f"
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "=https://api.hubapi.com/crm/v3/objects/contacts/{{ $('HubSpot: Search Contact').first().json.results[0].id }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotOAuth2Api",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ properties: { last_meeting_intel_date: $('Prepare Content').first().json.date, meeting_intel_url: 'https://github.com/hudsonlorfing/meeting-notes/blob/main/' + encodeURIComponent($('Prepare Content').first().json.filePath), meeting_intel_next_steps: ($('Prepare Content').first().json.structuredData?.follow_ups || []).slice(0, 3).join('; '), last_spiced_score: $('Prepare Content').first().json.scores?.spiced_score || '' } }) }}",
        "options": {}
      },
      "name": "HubSpot: Update Custom Props",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        4840,
        0
      ],
      "credentials": {
        "hubspotOAuth2Api": {
          "id": "3JZVnZQkHgMfXMRx",
          "name": "HubSpot account"
        }
      },
      "continueOnFail": true,
      "id": "hubspot-update-props-001"
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "update",
        "channelId": {
          "__rl": true,
          "mode": "id",
          "value": "={{ $('Prepare Content').first().json.channelId || $('Prepare Content').first().json.slackChannelId || 'C0AE7NPAWDQ' }}"
        },
        "ts": "={{ $('Prepare Content').first().json.messageTs }}",
        "messageType": "text",
        "text": "={{ '‚úÖ *Meeting Analyzed!*\\n\\nüìù ' + $('Prepare Content').first().json.displayTitle + '\\nü§ñ Apps: ' + ($('Prepare Content').first().json.apps || []).map(a => a.id).join(', ') + '\\nüë• ' + $('Prepare Content').first().json.personName + '\\n\\n' + ($('Prepare Content').first().json.structuredData?.summary || '') + '\\n\\n<https://github.com/hudsonlorfing/meeting-notes/blob/main/' + encodeURIComponent($('Prepare Content').first().json.filePath) + '|View on GitHub>' + ($('Prepare Content').first().json.totalTokens ? '\\n\\n_Tokens: ' + ($('Prepare Content').first().json.promptTokens || 0) + ' in / ' + ($('Prepare Content').first().json.completionTokens || 0) + ' out (' + $('Prepare Content').first().json.totalTokens + ' total)_' : '') }}",
        "updateFields": {}
      },
      "name": "Slack: Success in Thread",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.2,
      "position": [
        5060,
        200
      ],
      "id": "slack-success-thread-001",
      "credentials": {
        "slackApi": {
          "id": "wkLpZSqhXl2iesnC",
          "name": "Chrt Slack App"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Parse Slack Payload').first().json.responseUrl }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ replace_original: true, text: '‚ùå *Analysis Error*\\n\\n' + ($json.error || $json.message || 'Unknown error. Check n8n logs.') }) }}",
        "options": {}
      },
      "name": "Slack: Error",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1980,
        400
      ],
      "id": "fd985765-7754-419b-a83e-eccb56c53062"
    },
    {
      "parameters": {},
      "name": "Ignore Other Actions",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        880,
        400
      ],
      "id": "0ebce523-8f83-4861-abaf-56fe0a1c49fc"
    },
    {
      "parameters": {},
      "name": "No Contact",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        4620,
        200
      ],
      "id": "515853a4-2997-4f3d-aafc-bd7f2995db8b"
    }
  ],
  "connections": {
    "Slack Webhook": {
      "main": [
        [
          {
            "node": "Parse Slack Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Slack Payload": {
      "main": [
        [
          {
            "node": "Respond to Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Slack": {
      "main": [
        [
          {
            "node": "Is Analyze Action?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Analyze Action?": {
      "main": [
        [
          {
            "node": "Supabase: Get Meeting",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Ignore Other Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase: Get Meeting": {
      "main": [
        [
          {
            "node": "Merge Overrides",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Slack: Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Overrides": {
      "main": [
        [
          {
            "node": "Supabase: Mark Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase: Mark Processing": {
      "main": [
        [
          {
            "node": "Slack: Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Slack: Processing": {
      "main": [
        [
          {
            "node": "Is Granola?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Granola?": {
      "main": [
        [
          {
            "node": "Process Granola Transcript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fireflies: Re-Fetch Transcript (Legacy)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Granola Transcript": {
      "main": [
        [
          {
            "node": "Apps Script: Resolve Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fireflies: Re-Fetch Transcript (Legacy)": {
      "main": [
        [
          {
            "node": "Process Fireflies Transcript (Legacy)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Slack: Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Fireflies Transcript (Legacy)": {
      "main": [
        [
          {
            "node": "Apps Script: Resolve Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apps Script: Resolve Context": {
      "main": [
        [
          {
            "node": "Build AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build AI Prompt": {
      "main": [
        [
          {
            "node": "AI Agent: Analyze Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Claude": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent: Analyze Meeting",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Window Buffer Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent: Analyze Meeting",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent: Analyze Meeting": {
      "main": [
        [
          {
            "node": "Prepare Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Content": {
      "main": [
        [
          {
            "node": "Supabase: Save Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase: Save Conversation": {
      "main": [
        [
          {
            "node": "Supabase: Store Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase: Store Analysis": {
      "main": [
        [
          {
            "node": "Get Analysis ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Analysis ID": {
      "main": [
        [
          {
            "node": "Supabase: Mark Completed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase: Mark Completed": {
      "main": [
        [
          {
            "node": "Apps Script: Extract Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apps Script: Extract Memory": {
      "main": [
        [
          {
            "node": "GitHub: Commit Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GitHub: Commit Meeting": {
      "main": [
        [
          {
            "node": "HubSpot: Search Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HubSpot: Search Contact": {
      "main": [
        [
          {
            "node": "Has Contact?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Contact?": {
      "main": [
        [
          {
            "node": "HubSpot: Create Note",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HubSpot: Create Note": {
      "main": [
        [
          {
            "node": "HubSpot: Update Custom Props",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HubSpot: Update Custom Props": {
      "main": [
        [
          {
            "node": "Slack: Success in Thread",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Contact": {
      "main": [
        [
          {
            "node": "Slack: Success in Thread",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "YWP69Qgq0ZlCN7Gj",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "8e6566b8-68cd-4277-bd23-316cec33080b",
  "activeVersionId": "8e6566b8-68cd-4277-bd23-316cec33080b",
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-01-05T09:19:18.426Z",
      "createdAt": "2026-01-05T09:19:18.426Z",
      "role": "workflow:owner",
      "workflowId": "0PjeQ9VgbUgE5lnD",
      "projectId": "O7lTivDfRl72aS23"
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-02-14T00:19:20.869Z",
    "createdAt": "2026-02-14T00:19:20.869Z",
    "versionId": "8e6566b8-68cd-4277-bd23-316cec33080b",
    "workflowId": "0PjeQ9VgbUgE5lnD",
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "meeting-intel-action",
          "responseMode": "responseNode",
          "options": {}
        },
        "name": "Slack Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2,
        "position": [
          0,
          300
        ],
        "webhookId": "meeting-intel-action",
        "id": "0596aabe-a9ad-44e6-9403-e995277cf753"
      },
      {
        "parameters": {
          "jsCode": "// Parse Slack interaction payload ‚Äî Chrt-only (no workspace override)\nconst body = $input.first().json.body;\nlet payload;\n\nif (typeof body === 'string') {\n  const decoded = decodeURIComponent(body.replace('payload=', ''));\n  payload = JSON.parse(decoded);\n} else if (body?.payload) {\n  payload = typeof body.payload === 'string' ? JSON.parse(body.payload) : body.payload;\n} else {\n  payload = body;\n}\n\nconst action = payload.actions?.[0] || {};\nconst hash = action.value || '';\nconst actionId = action.action_id || '';\nconst state = payload.state?.values || {};\n\nconst recordingType = state.recording_type_block?.recording_type_select?.selected_option?.value || 'normal';\nconst detailLevel = state.detail_level_block?.detail_level_select?.selected_option?.value || 'standard';\nconst additionalAttendees = state.additional_attendees_block?.additional_attendees_input?.value || '';\n\nconst selectedApps = state.apps_block?.apps_select?.selected_options || [];\nlet appsOverride = null;\nif (selectedApps.length > 0) {\n  const weight = 1.0 / selectedApps.length;\n  appsOverride = selectedApps.map(opt => ({ id: opt.value, weight: Math.round(weight * 100) / 100 }));\n}\n\nconst customContext = state.custom_context_block?.custom_context_input?.value || '';\nconst user = payload.user?.username || payload.user?.name || 'unknown';\nconst responseUrl = payload.response_url || '';\nconst messageTs = payload.message?.ts || null;\nconst channelId = (typeof payload.channel === 'object' ? payload.channel?.id : payload.channel) || null;\n\nreturn [{ json: { hash, actionId, recordingType, detailLevel, additionalAttendees, appsOverride, customContext, user, responseUrl, messageTs, channelId } }];"
        },
        "name": "Parse Slack Payload",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          220,
          300
        ],
        "id": "888efc07-d4f8-4be4-acd8-dab28c361705"
      },
      {
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify({ text: '‚è≥ Processing...' }) }}"
        },
        "name": "Respond to Slack",
        "type": "n8n-nodes-base.respondToWebhook",
        "typeVersion": 1.1,
        "position": [
          440,
          300
        ],
        "id": "5bcfe588-f93c-4a57-a9b1-5585675240d8"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose",
              "version": 2
            },
            "conditions": [
              {
                "id": "is-analyze-action",
                "leftValue": "={{ $json.actionId }}",
                "rightValue": "analyze_meeting_v2",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "name": "Is Analyze Action?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          660,
          300
        ],
        "id": "0bb56810-2d52-4e74-bcba-9972172177ae"
      },
      {
        "parameters": {
          "method": "GET",
          "url": "=https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meetings?hash=eq.{{ $('Parse Slack Payload').first().json.hash }}&select=*",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "supabaseApi",
          "options": {}
        },
        "name": "Supabase: Get Meeting",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          880,
          200
        ],
        "credentials": {
          "supabaseApi": {
            "id": "HRBgSj7d6TFZA8kL",
            "name": "Supabase account 2"
          }
        },
        "onError": "continueErrorOutput",
        "id": "supabase-get-meeting-001"
      },
      {
        "parameters": {
          "jsCode": "// Extract meeting and merge with Slack overrides ‚Äî source-agnostic\nconst response = $input.first().json;\nconst meeting = Array.isArray(response) ? response[0] : response;\n\nif (!meeting || !meeting.hash) {\n  throw new Error('Meeting not found in Supabase');\n}\n\nconst slack = $('Parse Slack Payload').first().json;\nconst apps = slack.appsOverride || meeting.suggested_apps || [{ id: 'general-notes', weight: 1.0 }];\nconst recordingType = slack.recordingType || 'normal';\nconst detailLevel = slack.detailLevel || 'standard';\n\nlet finalAttendees = meeting.attendees_raw || '';\nif (slack.additionalAttendees) {\n  if (recordingType === 'singular') {\n    finalAttendees = slack.additionalAttendees;\n  } else {\n    finalAttendees = finalAttendees ? finalAttendees + ', ' + slack.additionalAttendees : slack.additionalAttendees;\n  }\n}\n\nreturn [{ json: {\n  meetingId: meeting.source_id,\n  sourceType: meeting.source_type || 'fireflies',\n  meetingUuid: meeting.id,\n  hash: meeting.hash,\n  title: meeting.title,\n  personName: meeting.person_name,\n  meetingDate: meeting.meeting_date,\n  dateStr: meeting.date_str,\n  durationMins: meeting.duration_mins,\n  attendees: finalAttendees,\n  sourceUrl: meeting.source_url,\n  sourceSummary: meeting.source_summary,\n  transcriptRaw: meeting.transcript_raw,\n  isExternal: meeting.is_external,\n  meetingType: meeting.meeting_type,\n  slackThreadTs: meeting.slack_thread_ts,\n  slackChannelId: meeting.slack_channel_id || slack.channelId || 'C0AE7NPAWDQ',\n  messageTs: slack.messageTs,\n  channelId: slack.channelId || meeting.slack_channel_id || 'C0AE7NPAWDQ',\n  finalApps: apps,\n  recordingType,\n  detailLevel,\n  additionalAttendees: slack.additionalAttendees || '',\n  customContext: slack.customContext,\n  user: slack.user,\n  responseUrl: slack.responseUrl\n} }];"
        },
        "name": "Merge Overrides",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1100,
          200
        ],
        "id": "eb55be27-c15a-41f4-9a79-8766794eeb03"
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "=https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meetings?hash=eq.{{ $('Parse Slack Payload').first().json.hash }}",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "supabaseApi",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Prefer",
                "value": "return=representation"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ status: 'processing' }) }}",
          "options": {}
        },
        "name": "Supabase: Mark Processing",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1320,
          200
        ],
        "credentials": {
          "supabaseApi": {
            "id": "HRBgSj7d6TFZA8kL",
            "name": "Supabase account 2"
          }
        },
        "id": "supabase-mark-processing-001"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $('Parse Slack Payload').first().json.responseUrl }}",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ replace_original: true, text: '‚è≥ *Analyzing:* ' + $('Merge Overrides').first().json.title + '\\n\\nü§ñ Using: ' + $('Merge Overrides').first().json.finalApps.map(a => a.id + ' (' + Math.round(a.weight * 100) + '%)').join(', ') }) }}",
          "options": {}
        },
        "name": "Slack: Processing",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1540,
          200
        ],
        "id": "f24eb243-1bca-485f-acc2-c35205305936"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose",
              "version": 2
            },
            "conditions": [
              {
                "id": "is-granola",
                "leftValue": "={{ $('Merge Overrides').first().json.sourceType }}",
                "rightValue": "granola",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "name": "Is Granola?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          1760,
          200
        ],
        "id": "is-granola-check-001"
      },
      {
        "parameters": {
          "jsCode": "// Process Granola transcript from stored transcript_raw\nconst merged = $('Merge Overrides').first().json;\nconst transcriptRaw = merged.transcriptRaw;\n\nif (!transcriptRaw || !Array.isArray(transcriptRaw) || transcriptRaw.length === 0) {\n  throw new Error('No stored transcript_raw found for Granola meeting: ' + merged.meetingId);\n}\n\n// Speaker inference (same logic as WF6)\nconst chrtDomains = ['chrt.com', 'getchrt.com'];\nconst attendeeList = (merged.attendees || '').split(',').map(a => a.trim()).filter(Boolean);\nconst participantEmails = attendeeList.filter(a => a.includes('@'));\nconst externals = participantEmails.filter(e => !chrtDomains.some(d => e.toLowerCase().includes(d)));\nconst internals = participantEmails.filter(e => chrtDomains.some(d => e.toLowerCase().includes(d)));\nconst isOneOnOne = externals.length === 1;\n\n// Determine speaker labels\nconst ownerEmail = internals[0] || '';\nconst ownerName = merged.personName ? '' : '';\n// For Chrt rep: use known names or email prefix\nlet chrtLabel = 'Chrt Rep';\nif (ownerEmail) {\n  const prefix = ownerEmail.split('@')[0];\n  chrtLabel = prefix.charAt(0).toUpperCase() + prefix.slice(1);\n}\n\nlet externalLabel = 'External';\nif (isOneOnOne && externals[0]) {\n  const prefix = externals[0].split('@')[0].split('.');\n  externalLabel = prefix.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ');\n}\n\nconst transcriptLines = transcriptRaw.map(seg => {\n  const ts = seg.start_time\n    ? new Date(seg.start_time).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })\n    : '';\n  const timePrefix = ts ? `[${ts}] ` : '';\n\n  if (seg.speaker && seg.speaker.source === 'microphone') {\n    return `${timePrefix}[Chrt - ${chrtLabel}]: ${seg.text}`;\n  } else if (isOneOnOne) {\n    return `${timePrefix}[External - ${externalLabel}]: ${seg.text}`;\n  } else {\n    return `${timePrefix}[External]: ${seg.text}`;\n  }\n});\n\nconst transcriptText = transcriptLines.join('\\n');\n\nreturn [{ json: {\n  ...merged,\n  transcript: transcriptText,\n  transcriptLength: transcriptText.length,\n  participantEmails\n} }];"
        },
        "name": "Process Granola Transcript",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1980,
          100
        ],
        "id": "process-granola-transcript-001"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.fireflies.ai/graphql",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpHeaderAuth",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ query: `{ transcript(id: \"${$('Merge Overrides').first().json.meetingId}\") { id title date duration organizer_email participants sentences { speaker_name text } summary { overview } } }` }) }}",
          "options": {
            "timeout": 60000,
            "retry": {
              "enabled": true,
              "maxRetries": 2,
              "waitBetweenRetries": 5000
            }
          }
        },
        "name": "Fireflies: Re-Fetch Transcript (Legacy)",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1980,
          300
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "E59l4LdE1u7lD39v",
            "name": "Fireflies API"
          }
        },
        "onError": "continueErrorOutput",
        "id": "fireflies-refetch-001"
      },
      {
        "parameters": {
          "jsCode": "// Extract transcript text from re-fetched Fireflies data (legacy path)\nconst response = $input.first().json;\nconst transcript = response.data?.transcript;\n\nif (!transcript) {\n  throw new Error('Transcript re-fetch failed: ' + JSON.stringify(response.errors || response).substring(0, 200));\n}\n\nconst transcriptText = (transcript.sentences || []).map(s => `${s.speaker_name}: ${s.text}`).join('\\n');\nconst merged = $('Merge Overrides').first().json;\n\n// Extract emails from attendees for Apps Script context resolution\nconst attendeeList = (merged.attendees || '').split(',').map(a => a.trim()).filter(Boolean);\nconst participantEmails = attendeeList.filter(a => a.includes('@'));\n\nreturn [{ json: {\n  ...merged,\n  transcript: transcriptText,\n  transcriptLength: transcriptText.length,\n  participantEmails\n} }];"
        },
        "name": "Process Fireflies Transcript (Legacy)",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2200,
          300
        ],
        "id": "process-refetch-001"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://script.google.com/macros/s/AKfycbybWTFvdZnmPnQkndxAqA4jQQlMC2_gGMZOJULYk5ywyc0IPT2qNn7QIq5SAtC_jUJJRA/exec",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ action: 'resolve-context', participant_emails: $json.participantEmails, meeting_id: $json.meetingUuid }) }}",
          "options": {
            "timeout": 30000
          }
        },
        "name": "Apps Script: Resolve Context",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2200,
          200
        ],
        "continueOnFail": true,
        "id": "apps-script-resolve-context-001"
      },
      {
        "parameters": {
          "jsCode": "// Build AI Agent prompt with Chrt context, templates, and resolved context\n// Source-agnostic: works for both Granola and Fireflies transcript paths\nconst meeting = (() => {\n  try { return $('Process Granola Transcript').first().json; } catch(e) {}\n  try { return $('Process Fireflies Transcript (Legacy)').first().json; } catch(e) {}\n  throw new Error('No transcript data found from either Granola or Fireflies path');\n})();\nconst contextResponse = $input.first().json;\nconst resolvedContext = contextResponse.participants || [];\n\n// Build context injection\nlet contextBlock = '';\nif (resolvedContext.length > 0) {\n  contextBlock = '\\n\\n## Prior Context\\n';\n  resolvedContext.forEach(p => {\n    if (p.hubspot) {\n      contextBlock += `\\n### HubSpot: ${p.hubspot.firstname || ''} ${p.hubspot.lastname || ''}\\n`;\n      contextBlock += `- Company: ${p.hubspot.company || 'Unknown'}\\n`;\n      contextBlock += `- Title: ${p.hubspot.jobtitle || 'Unknown'}\\n`;\n      contextBlock += `- Stage: ${p.hubspot.lifecyclestage || 'Unknown'}\\n`;\n      if (p.hubspot.deals?.length > 0) {\n        contextBlock += `- Deals: ${p.hubspot.deals.map(d => d.name + ' (' + d.stage + ')').join(', ')}\\n`;\n      }\n      if (p.hubspot.last_spiced_score) {\n        contextBlock += `- Last SPICED Score: ${p.hubspot.last_spiced_score}\\n`;\n      }\n    }\n    if (p.prior_meetings?.length > 0) {\n      contextBlock += '\\n#### Prior Meetings:\\n';\n      p.prior_meetings.forEach(m => {\n        contextBlock += `- ${m.date}: ${m.title} (${m.type})\\n`;\n        if (m.summary) contextBlock += `  Summary: ${m.summary}\\n`;\n        if (m.scores) contextBlock += `  Scores: ${JSON.stringify(m.scores)}\\n`;\n      });\n    }\n    if (p.memory?.length > 0) {\n      contextBlock += '\\n#### Known Facts:\\n';\n      p.memory.forEach(f => {\n        contextBlock += `- [${f.type}] ${f.entity}: ${f.fact} (${f.confidence})\\n`;\n      });\n    }\n  });\n}\n\n// Build template instructions from apps\nconst apps = meeting.finalApps || [{id: 'general-notes', weight: 1.0}];\nconst templateInstructions = apps.map(a =>\n  `Analyze using template: ${a.id} (weight: ${Math.round(a.weight * 100)}%)`\n).join('\\n');\n\nconst systemPrompt = `You are Chrt's meeting intelligence analyst. Chrt is a B2B SaaS company selling real-time visibility and coordination software for time-critical logistics (medical, aerospace, industrial).\n\nTeam: Hudson Lorfing (CEO), Aaron Carver (Sales), Kyle Reagan (Sales).\nMethodology: SPICED framework.\nCustomer segments: Shippers (labs, hospitals, manufacturers), Couriers (last-mile delivery), Forwarders (3PLs, freight brokers).\n\nYour task: Analyze the meeting transcript and produce structured intelligence.\n\n${templateInstructions}\n\nOutput your analysis as structured JSON with these fields:\n- summary: 2-3 sentence executive summary\n- key_points: array of key discussion points\n- action_items: array of {owner, task, due} objects\n- decisions: array of decisions made\n- follow_ups: array of follow-up items\n- key_quotes: array of {speaker, text} objects\n- scores: object with any applicable scorecard results\n- analysis: detailed markdown analysis following the template format\n\n${meeting.customContext ? '\\nAdditional context from user: ' + meeting.customContext : ''}\n${contextBlock}`;\n\nconst userMessage = `Meeting: ${meeting.title}\\nDate: ${meeting.dateStr}\\nDuration: ${meeting.durationMins} min\\nAttendees: ${meeting.attendees}\\nType: ${meeting.meetingType} (${meeting.isExternal ? 'External' : 'Internal'})\\n${meeting.recordingType === 'singular' ? 'Note: This is a singular recording (speaker was alone)' : ''}\\n${meeting.detailLevel === 'context' ? 'Note: User requested detailed/context-level notes' : ''}\\n\\n## Transcript\\n\\n${meeting.transcript}`;\n\nreturn [{ json: {\n  ...meeting,\n  systemPrompt,\n  userMessage,\n  resolvedContext\n} }];"
        },
        "name": "Build AI Prompt",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2420,
          200
        ],
        "id": "build-ai-prompt-001"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "={{ $json.userMessage }}",
          "options": {
            "systemMessage": "={{ $json.systemPrompt }}",
            "maxTokens": 8192,
            "temperature": 0.3
          }
        },
        "name": "AI Agent: Analyze Meeting",
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 1.7,
        "position": [
          2640,
          200
        ],
        "id": "ai-agent-analyze-001"
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "value": "claude-sonnet-4-5-20250929",
            "mode": "list",
            "cachedResultName": "Claude Sonnet 4.5"
          },
          "options": {
            "maxTokensToSample": 8192,
            "temperature": 0.3
          }
        },
        "name": "Anthropic Claude",
        "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
        "typeVersion": 1.3,
        "position": [
          2560,
          420
        ],
        "credentials": {
          "anthropicApi": {
            "id": "B6k4mmzjw7OzEK5c",
            "name": "Anthropic account"
          }
        },
        "id": "anthropic-claude-001"
      },
      {
        "parameters": {
          "sessionIdType": "customKey",
          "sessionKey": "={{ $('Build AI Prompt').first().json.slackThreadTs || $('Build AI Prompt').first().json.meetingUuid }}"
        },
        "name": "Window Buffer Memory",
        "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
        "typeVersion": 1.3,
        "position": [
          2720,
          420
        ],
        "id": "window-buffer-memory-001"
      },
      {
        "parameters": {
          "jsCode": "// Parse AI response and build structured output\nconst aiResponse = $input.first().json;\nconst meeting = $('Build AI Prompt').first().json;\nconst output = aiResponse.output || aiResponse.text || '';\n\n// Try to parse structured JSON from the response\nlet structuredData = {};\nlet analysisOutput = output;\n\ntry {\n  // Look for JSON block in the response\n  const jsonMatch = output.match(/```json\\n([\\s\\S]*?)\\n```/) || output.match(/\\{[\\s\\S]*\"summary\"[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    const jsonStr = jsonMatch[1] || jsonMatch[0];\n    structuredData = JSON.parse(jsonStr);\n    // Extract the analysis markdown if separate from JSON\n    analysisOutput = structuredData.analysis || output.replace(/```json[\\s\\S]*?```/, '').trim() || output;\n  } else {\n    // Build minimal structured data from plain text\n    structuredData = {\n      summary: output.substring(0, 500),\n      key_points: [],\n      action_items: [],\n      decisions: [],\n      follow_ups: [],\n      key_quotes: []\n    };\n    analysisOutput = output;\n  }\n} catch (e) {\n  console.log('Could not parse structured JSON: ' + e.message);\n  structuredData = { summary: output.substring(0, 500) };\n  analysisOutput = output;\n}\n\nconst scores = structuredData.scores || null;\n\n// Build Obsidian-compatible markdown\nconst dateStr = meeting.dateStr || new Date().toISOString().split('T')[0];\nconst personName = (meeting.personName || 'Team').replace(/[^a-zA-Z0-9 -]/g, '').trim();\nconst displayTitle = `${dateStr}Íûâ Meeting with ${personName}`;\nconst filePath = `chrt/${displayTitle}.md`;\n\nconst attendeeList = (meeting.attendees || '').split(',').map(a => a.trim()).filter(Boolean);\nconst participantLinks = attendeeList.filter(a => !a.toLowerCase().includes('hudson')).map(a => {\n  const name = a.includes('@') ? a.split('@')[0].split('.').map(p => p.charAt(0).toUpperCase() + p.slice(1)).join(' ') : a;\n  return `\"[[üë§${name.replace(/[^a-zA-Z0-9 -]/g, '').trim()}]]\"`;\n});\n\nconst appsUsed = (meeting.finalApps || []).map(a => a.id).join(', ');\nconst frontmatter = `---\\nup: \\nin:\\n  - \"[[Meetings]]\"\\nrelated: \\ncreated: ${dateStr}\\ntags:\\n  - meeting\\n  - chrt\\nmeeting_date: ${dateStr}\\nmeeting_with: \"[[üë§${personName}]]\"\\nparticipants:\\n${participantLinks.map(p => `  - ${p}`).join('\\n')}\\nanalysis_apps: [${appsUsed}]\\nmodel: claude-sonnet\\nprocessed_by: ${meeting.user}\\none-liner: \\n---\\n\\n# ${displayTitle}\\n*Meeting on ${dateStr}*\\n\\n## Participants\\n${participantLinks.map(p => `- ${p}`).join('\\n')}\\n\\n`;\n\nconst fullContent = frontmatter + analysisOutput;\n\nconst primaryEmail = attendeeList.find(a => a.includes('@') && !a.includes('chrt.com')) || '';\n\n// Extract token usage from AI agent response\nconst tokenUsage = aiResponse.tokenUsage || {};\nconst promptTokens = tokenUsage.promptTokens || 0;\nconst completionTokens = tokenUsage.completionTokens || 0;\nconst totalTokens = tokenUsage.totalTokens || (promptTokens + completionTokens);\n\nreturn [{ json: {\n  hash: meeting.hash,\n  meetingUuid: meeting.meetingUuid,\n  filePath,\n  fileName: displayTitle + '.md',\n  content: fullContent,\n  analysisOutput,\n  structuredData,\n  scores,\n  title: meeting.title,\n  displayTitle,\n  date: dateStr,\n  primaryEmail,\n  personName,\n  apps: meeting.finalApps,\n  model: 'claude-sonnet',\n  responseUrl: meeting.responseUrl,\n  slackThreadTs: meeting.slackThreadTs,\n  slackChannelId: meeting.slackChannelId,\n  messageTs: meeting.messageTs,\n  channelId: meeting.channelId || meeting.slackChannelId,\n  isExternal: meeting.isExternal,\n  participantEmails: meeting.participantEmails || [],\n  resolvedContext: meeting.resolvedContext || [],\n  promptTokens,\n  completionTokens,\n  totalTokens\n} }];"
        },
        "name": "Prepare Content",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2860,
          200
        ],
        "id": "85d82602-7181-405b-a39b-fe391f0e2567"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/agent_conversations",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "supabaseApi",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Prefer",
                "value": "return=minimal"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify([ { session_id: $('Prepare Content').first().json.slackThreadTs || $('Prepare Content').first().json.meetingUuid || 'unknown', role: 'system', content: 'Analysis of: ' + $('Prepare Content').first().json.title + ' (' + $('Prepare Content').first().json.date + ')' }, { session_id: $('Prepare Content').first().json.slackThreadTs || $('Prepare Content').first().json.meetingUuid || 'unknown', role: 'assistant', content: ($('Prepare Content').first().json.structuredData?.summary || $('Prepare Content').first().json.analysisOutput || '').substring(0, 4000) } ]) }}",
          "options": {}
        },
        "name": "Supabase: Save Conversation",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          2940,
          100
        ],
        "credentials": {
          "supabaseApi": {
            "id": "HRBgSj7d6TFZA8kL",
            "name": "Supabase account 2"
          }
        },
        "continueOnFail": true,
        "id": "supabase-save-conversation-001"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meeting_analyses",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "supabaseApi",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Prefer",
                "value": "return=representation"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ meeting_id: $('Prepare Content').first().json.meetingUuid, template_id: ($('Prepare Content').first().json.apps && $('Prepare Content').first().json.apps[0]) ? $('Prepare Content').first().json.apps[0].id : 'general-notes', analysis_output: $('Prepare Content').first().json.analysisOutput, structured_data: $('Prepare Content').first().json.structuredData, scores: $('Prepare Content').first().json.scores, model_used: $('Prepare Content').first().json.model, token_count: $('Prepare Content').first().json.totalTokens || 0, created_by: $('Prepare Content').first().json.personName || 'system' }) }}",
          "options": {}
        },
        "name": "Supabase: Store Analysis",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3080,
          200
        ],
        "credentials": {
          "supabaseApi": {
            "id": "HRBgSj7d6TFZA8kL",
            "name": "Supabase account 2"
          }
        },
        "id": "supabase-store-analysis-001"
      },
      {
        "parameters": {
          "jsCode": "// Extract analysis ID from Supabase response, update meeting status\nconst analysisResp = $input.first().json;\nconst analysisId = Array.isArray(analysisResp) ? analysisResp[0]?.id : analysisResp?.id;\nconst prep = $('Prepare Content').first().json;\n\nreturn [{ json: { ...prep, analysisId } }];"
        },
        "name": "Get Analysis ID",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3300,
          200
        ],
        "id": "get-analysis-id-001"
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "=https://utvoxshpxzsgsliworwh.supabase.co/rest/v1/meetings?hash=eq.{{ $json.hash }}",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "supabaseApi",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Prefer",
                "value": "return=representation"
              }
            ]
          },
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ status: 'completed' }) }}",
          "options": {}
        },
        "name": "Supabase: Mark Completed",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3520,
          200
        ],
        "credentials": {
          "supabaseApi": {
            "id": "HRBgSj7d6TFZA8kL",
            "name": "Supabase account 2"
          }
        },
        "id": "supabase-mark-completed-001"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://script.google.com/macros/s/AKfycbybWTFvdZnmPnQkndxAqA4jQQlMC2_gGMZOJULYk5ywyc0IPT2qNn7QIq5SAtC_jUJJRA/exec",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ action: 'extract-memory', analysis_id: $('Get Analysis ID').first().json.analysisId, meeting_id: $('Prepare Content').first().json.meetingUuid, structured_data: $('Prepare Content').first().json.structuredData, participants: ($('Prepare Content').first().json.participantEmails || []).map(e => ({ email: e })) }) }}",
          "options": {
            "timeout": 30000
          }
        },
        "name": "Apps Script: Extract Memory",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          3740,
          200
        ],
        "continueOnFail": true,
        "id": "apps-script-extract-memory-001"
      },
      {
        "parameters": {
          "resource": "file",
          "operation": "create",
          "owner": {
            "__rl": true,
            "mode": "name",
            "value": "hudsonlorfing"
          },
          "repository": {
            "__rl": true,
            "mode": "name",
            "value": "meeting-notes"
          },
          "filePath": "={{ $('Prepare Content').first().json.filePath }}",
          "fileContent": "={{ $('Prepare Content').first().json.content }}",
          "commitMessage": "={{ 'Add meeting (chrt): ' + $('Prepare Content').first().json.displayTitle }}",
          "additionalParameters": {}
        },
        "name": "GitHub: Commit Meeting",
        "type": "n8n-nodes-base.github",
        "typeVersion": 1.1,
        "position": [
          3960,
          200
        ],
        "credentials": {
          "githubApi": {
            "id": "yiGNsTvCmOQmaC7f",
            "name": "GitHub PAT - Workflows"
          }
        },
        "continueOnFail": true,
        "id": "1e533e25-de72-4708-b3da-53c08e4d4438"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.hubapi.com/crm/v3/objects/contacts/search",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "hubspotOAuth2Api",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ filterGroups: [{ filters: [{ propertyName: 'email', operator: 'CONTAINS_TOKEN', value: $('Prepare Content').first().json.primaryEmail || '*' }] }], properties: ['email', 'firstname', 'lastname', 'company'] }) }}",
          "options": {}
        },
        "name": "HubSpot: Search Contact",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          4180,
          100
        ],
        "credentials": {
          "hubspotOAuth2Api": {
            "id": "3JZVnZQkHgMfXMRx",
            "name": "HubSpot account"
          }
        },
        "continueOnFail": true,
        "id": "bd950bbe-0e54-4b30-b4c7-ab91df0e4c0e"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose",
              "version": 2
            },
            "conditions": [
              {
                "id": "has-contact",
                "leftValue": "={{ $json.results?.length > 0 }}",
                "rightValue": true,
                "operator": {
                  "type": "boolean",
                  "operation": "equals"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "name": "Has Contact?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          4400,
          100
        ],
        "id": "16a7a1d2-1ea2-48d7-875e-4cf57ebaa34d"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.hubapi.com/crm/v3/objects/notes",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "hubspotOAuth2Api",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ properties: { hs_note_body: '## Meeting Intel: ' + $('Prepare Content').first().json.title + '\\n\\n**Analysis Apps:** ' + ($('Prepare Content').first().json.apps || []).map(a => a.id).join(', ') + '\\n**Date:** ' + $('Prepare Content').first().json.date + '\\n**Type:** ' + ($('Prepare Content').first().json.isExternal ? 'External' : 'Internal') + '\\n\\n' + ($('Prepare Content').first().json.structuredData?.summary || 'See full analysis') + '\\n\\n### Key Points\\n' + ($('Prepare Content').first().json.structuredData?.key_points || []).map(p => '- ' + p).join('\\n') + '\\n\\n### Action Items\\n' + ($('Prepare Content').first().json.structuredData?.action_items || []).map(a => '- ' + (a.owner || '') + ': ' + (a.task || a)).join('\\n') + '\\n\\n[View Full Analysis](https://github.com/hudsonlorfing/meeting-notes/blob/main/' + encodeURIComponent($('Prepare Content').first().json.filePath) + ')', hs_timestamp: new Date($('Prepare Content').first().json.date).getTime() }, associations: [{ to: { id: $('HubSpot: Search Contact').first().json.results[0].id }, types: [{ associationCategory: 'HUBSPOT_DEFINED', associationTypeId: 10 }] }] }) }}",
          "options": {}
        },
        "name": "HubSpot: Create Note",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          4620,
          0
        ],
        "credentials": {
          "hubspotOAuth2Api": {
            "id": "3JZVnZQkHgMfXMRx",
            "name": "HubSpot account"
          }
        },
        "continueOnFail": true,
        "id": "91c468a4-1409-4c34-8113-15915be88b1f"
      },
      {
        "parameters": {
          "method": "PATCH",
          "url": "=https://api.hubapi.com/crm/v3/objects/contacts/{{ $('HubSpot: Search Contact').first().json.results[0].id }}",
          "authentication": "predefinedCredentialType",
          "nodeCredentialType": "hubspotOAuth2Api",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ properties: { last_meeting_intel_date: $('Prepare Content').first().json.date, meeting_intel_url: 'https://github.com/hudsonlorfing/meeting-notes/blob/main/' + encodeURIComponent($('Prepare Content').first().json.filePath), meeting_intel_next_steps: ($('Prepare Content').first().json.structuredData?.follow_ups || []).slice(0, 3).join('; '), last_spiced_score: $('Prepare Content').first().json.scores?.spiced_score || '' } }) }}",
          "options": {}
        },
        "name": "HubSpot: Update Custom Props",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          4840,
          0
        ],
        "credentials": {
          "hubspotOAuth2Api": {
            "id": "3JZVnZQkHgMfXMRx",
            "name": "HubSpot account"
          }
        },
        "continueOnFail": true,
        "id": "hubspot-update-props-001"
      },
      {
        "parameters": {
          "resource": "message",
          "operation": "update",
          "channelId": {
            "__rl": true,
            "mode": "id",
            "value": "={{ $('Prepare Content').first().json.channelId || $('Prepare Content').first().json.slackChannelId || 'C0AE7NPAWDQ' }}"
          },
          "ts": "={{ $('Prepare Content').first().json.messageTs }}",
          "messageType": "text",
          "text": "={{ '‚úÖ *Meeting Analyzed!*\\n\\nüìù ' + $('Prepare Content').first().json.displayTitle + '\\nü§ñ Apps: ' + ($('Prepare Content').first().json.apps || []).map(a => a.id).join(', ') + '\\nüë• ' + $('Prepare Content').first().json.personName + '\\n\\n' + ($('Prepare Content').first().json.structuredData?.summary || '') + '\\n\\n<https://github.com/hudsonlorfing/meeting-notes/blob/main/' + encodeURIComponent($('Prepare Content').first().json.filePath) + '|View on GitHub>' + ($('Prepare Content').first().json.totalTokens ? '\\n\\n_Tokens: ' + ($('Prepare Content').first().json.promptTokens || 0) + ' in / ' + ($('Prepare Content').first().json.completionTokens || 0) + ' out (' + $('Prepare Content').first().json.totalTokens + ' total)_' : '') }}",
          "updateFields": {}
        },
        "name": "Slack: Success in Thread",
        "type": "n8n-nodes-base.slack",
        "typeVersion": 2.2,
        "position": [
          5060,
          200
        ],
        "id": "slack-success-thread-001",
        "credentials": {
          "slackApi": {
            "id": "wkLpZSqhXl2iesnC",
            "name": "Chrt Slack App"
          }
        }
      },
      {
        "parameters": {
          "method": "POST",
          "url": "={{ $('Parse Slack Payload').first().json.responseUrl }}",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ JSON.stringify({ replace_original: true, text: '‚ùå *Analysis Error*\\n\\n' + ($json.error || $json.message || 'Unknown error. Check n8n logs.') }) }}",
          "options": {}
        },
        "name": "Slack: Error",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          1980,
          400
        ],
        "id": "fd985765-7754-419b-a83e-eccb56c53062"
      },
      {
        "parameters": {},
        "name": "Ignore Other Actions",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          880,
          400
        ],
        "id": "0ebce523-8f83-4861-abaf-56fe0a1c49fc"
      },
      {
        "parameters": {},
        "name": "No Contact",
        "type": "n8n-nodes-base.noOp",
        "typeVersion": 1,
        "position": [
          4620,
          200
        ],
        "id": "515853a4-2997-4f3d-aafc-bd7f2995db8b"
      }
    ],
    "connections": {
      "Slack Webhook": {
        "main": [
          [
            {
              "node": "Parse Slack Payload",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parse Slack Payload": {
        "main": [
          [
            {
              "node": "Respond to Slack",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Respond to Slack": {
        "main": [
          [
            {
              "node": "Is Analyze Action?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Is Analyze Action?": {
        "main": [
          [
            {
              "node": "Supabase: Get Meeting",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Ignore Other Actions",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Supabase: Get Meeting": {
        "main": [
          [
            {
              "node": "Merge Overrides",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Slack: Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Overrides": {
        "main": [
          [
            {
              "node": "Supabase: Mark Processing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Supabase: Mark Processing": {
        "main": [
          [
            {
              "node": "Slack: Processing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Slack: Processing": {
        "main": [
          [
            {
              "node": "Is Granola?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Is Granola?": {
        "main": [
          [
            {
              "node": "Process Granola Transcript",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Fireflies: Re-Fetch Transcript (Legacy)",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Process Granola Transcript": {
        "main": [
          [
            {
              "node": "Apps Script: Resolve Context",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fireflies: Re-Fetch Transcript (Legacy)": {
        "main": [
          [
            {
              "node": "Process Fireflies Transcript (Legacy)",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Slack: Error",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Process Fireflies Transcript (Legacy)": {
        "main": [
          [
            {
              "node": "Apps Script: Resolve Context",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Apps Script: Resolve Context": {
        "main": [
          [
            {
              "node": "Build AI Prompt",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build AI Prompt": {
        "main": [
          [
            {
              "node": "AI Agent: Analyze Meeting",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Anthropic Claude": {
        "ai_languageModel": [
          [
            {
              "node": "AI Agent: Analyze Meeting",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Window Buffer Memory": {
        "ai_memory": [
          [
            {
              "node": "AI Agent: Analyze Meeting",
              "type": "ai_memory",
              "index": 0
            }
          ]
        ]
      },
      "AI Agent: Analyze Meeting": {
        "main": [
          [
            {
              "node": "Prepare Content",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Content": {
        "main": [
          [
            {
              "node": "Supabase: Save Conversation",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Supabase: Save Conversation": {
        "main": [
          [
            {
              "node": "Supabase: Store Analysis",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Supabase: Store Analysis": {
        "main": [
          [
            {
              "node": "Get Analysis ID",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Analysis ID": {
        "main": [
          [
            {
              "node": "Supabase: Mark Completed",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Supabase: Mark Completed": {
        "main": [
          [
            {
              "node": "Apps Script: Extract Memory",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Apps Script: Extract Memory": {
        "main": [
          [
            {
              "node": "GitHub: Commit Meeting",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "GitHub: Commit Meeting": {
        "main": [
          [
            {
              "node": "HubSpot: Search Contact",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "HubSpot: Search Contact": {
        "main": [
          [
            {
              "node": "Has Contact?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has Contact?": {
        "main": [
          [
            {
              "node": "HubSpot: Create Note",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "No Contact",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "HubSpot: Create Note": {
        "main": [
          [
            {
              "node": "HubSpot: Update Custom Props",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "HubSpot: Update Custom Props": {
        "main": [
          [
            {
              "node": "Slack: Success in Thread",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "No Contact": {
        "main": [
          [
            {
              "node": "Slack: Success in Thread",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Hudson Lorfing",
    "name": null,
    "description": null,
    "autosaved": false
  },
  "tags": [],
  "_folderPath": "",
  "_fileName": "7.-slack-interaction-handler.json"
}